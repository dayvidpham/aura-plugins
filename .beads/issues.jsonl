{"id":"aura-plugins-06g","title":"IMPL_PLAN: Machine-executable aura protocol engine v1 MVP","description":"---\nreferences:\n  request: aura-plugins-bj1\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n  handoff: aura-plugins-b5m\n---\n## Layer Structure (TDD)\n\n### Vertical Slices\n- SLICE-1 (aura-plugins-35d): types.py — Protocol type definitions (enums, frozen specs, lookup dicts)\n  - SLICE-1-IMPL (aura-plugins-9nc): types.py + __init__.py\n  - SLICE-1-TESTS (aura-plugins-g2a): test_aura_types.py + test_schema_types_sync.py\n  - Deps: None (foundation)\n- SLICE-2 (aura-plugins-la6): state_machine.py — 12-phase epoch lifecycle\n  - SLICE-2-L1 (aura-plugins-125): Type structure\n  - SLICE-2-L2 (aura-plugins-4mu): test_state_machine.py\n  - SLICE-2-L3 (aura-plugins-0n3): Implementation\n  - Deps: SLICE-1\n- SLICE-3 (aura-plugins-mrm): constraints.py — Runtime constraint validators\n  - SLICE-3-L1 (aura-plugins-eel): Type structure\n  - SLICE-3-L2 (aura-plugins-w28): test_constraints.py\n  - SLICE-3-L3 (aura-plugins-9ii): Implementation\n  - Deps: SLICE-1, SLICE-2\n- SLICE-4 (aura-plugins-8i5): interfaces.py — Cross-project integration + A2A types\n  - SLICE-4-L1 (aura-plugins-1cy): Protocol interfaces + A2A types\n  - SLICE-4-L2 (aura-plugins-exe): test_interfaces.py\n  - SLICE-4-L3 (aura-plugins-0rd): ModelId.parse() + event stubs\n  - Deps: SLICE-1 only\n- SLICE-5 (aura-plugins-lkz): workflow.py — Temporal workflow wrapper\n  - SLICE-5-L1 (aura-plugins-r1n): Temporal types + search attrs + pyproject.toml\n  - SLICE-5-L2 (aura-plugins-amx): test_workflow.py\n  - SLICE-5-L3 (aura-plugins-2au): EpochWorkflow + activities\n  - Deps: SLICE-1, SLICE-2, SLICE-3\n\n## Parallelism Layers\n- Layer 0: SLICE-1 (foundation, solo)\n- Layer 1: SLICE-2 + SLICE-4 (parallel after SLICE-1)\n- Layer 2: SLICE-3 (after SLICE-2)\n- Layer 3: SLICE-5 (after SLICE-3)\n\n## BDD Acceptance Criteria (10)\nAC1-AC10 from RATIFIED_PLAN (aura-plugins-gmv)","status":"in_progress","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:28:48Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:33:36Z","labels":["aura:p8-impl:s8-plan"],"dependencies":[{"issue_id":"aura-plugins-06g","depends_on_id":"aura-plugins-35d","type":"blocks","created_at":"2026-02-21T17:31:27Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-06g","depends_on_id":"aura-plugins-3r4","type":"blocks","created_at":"2026-02-21T18:59:44Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-06g","depends_on_id":"aura-plugins-8i5","type":"blocks","created_at":"2026-02-21T17:31:29Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-06g","depends_on_id":"aura-plugins-e0j","type":"blocks","created_at":"2026-02-21T18:18:30Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-06g","depends_on_id":"aura-plugins-la6","type":"blocks","created_at":"2026-02-21T17:31:28Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-06g","depends_on_id":"aura-plugins-lkz","type":"blocks","created_at":"2026-02-21T17:31:30Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-06g","depends_on_id":"aura-plugins-mrm","type":"blocks","created_at":"2026-02-21T17:31:29Z","created_by":"David Huu Pham","metadata":"{}"}],"comments":[{"id":9,"issue_id":"aura-plugins-06g","author":"David Huu Pham","text":"Phase 8 complete. IMPL_PLAN decomposed into 5 vertical slices with 14 leaf tasks. Handoff docs created for all workers. SLICE-1 worker spawned (Worker-1). Waiting for SLICE-1 foundation to complete before spawning Layer 1 (SLICE-2 + SLICE-4 in parallel).","created_at":"2026-02-22T01:36:08Z"},{"id":11,"issue_id":"aura-plugins-06g","author":"David Huu Pham","text":"SLICE-1 complete. 65 tests pass (49 unit + 16 integration). No regressions on existing 95 tests. Spawning Layer 1: SLICE-2 + SLICE-4 in parallel.","created_at":"2026-02-22T01:42:54Z"},{"id":13,"issue_id":"aura-plugins-06g","author":"David Huu Pham","text":"SLICE-4 complete. 47 new tests, 207 total passing. Event stubs re-exported from types.py (no duplication). Waiting for SLICE-2 to complete before spawning SLICE-3.","created_at":"2026-02-22T01:47:29Z"},{"id":15,"issue_id":"aura-plugins-06g","author":"David Huu Pham","text":"SLICE-2 complete. 57 new tests, 264 total passing. Spawning Layer 2: SLICE-3 (constraints.py).","created_at":"2026-02-22T01:50:55Z"},{"id":17,"issue_id":"aura-plugins-06g","author":"David Huu Pham","text":"SLICE-3 complete. 154 new tests (22 C-* constraints), 418 total passing. Spawning Layer 3: SLICE-5 (workflow.py — final slice).","created_at":"2026-02-22T02:05:53Z"},{"id":19,"issue_id":"aura-plugins-06g","author":"David Huu Pham","text":"All 5 slices COMPLETE. 458 tests passing. Proceeding to agent-commit, then Phase 10 (code review).","created_at":"2026-02-22T02:17:12Z"},{"id":20,"issue_id":"aura-plugins-06g","author":"David Huu Pham","text":"All 5 slices committed. 458 tests pass. Working tree clean. 7 commits ahead of origin. Proceeding to Phase 10: code review (3 reviewers, all slices).","created_at":"2026-02-22T02:18:09Z"},{"id":38,"issue_id":"aura-plugins-06g","author":"David Huu Pham","text":"Phase 10 complete. 3/3 ACCEPT, 0 BLOCKERs. EPIC_FOLLOWUP created (aura-plugins-2tj) with IMPORTANT/MINOR findings. Proceeding to Phase 11 (UAT).","created_at":"2026-02-22T02:27:45Z"}]}
{"id":"aura-plugins-0ac","title":"SLICE-4-REVIEW-C-1 IMPORTANT","description":"Reviewer C (Elegance) — SLICE-4 IMPORTANT severity group.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:46Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:23:05Z","closed_at":"2026-02-22T02:23:05Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-0gt","title":"SLICE-2-REVIEW-C-1: state_machine.py — 12-phase lifecycle","description":"VOTE: ACCEPT\n\n## Review Summary (Reviewer C — Elegance and Complexity Proportionality)\n\nSLICE-2 (state_machine.py) implements the state machine with appropriate complexity for the fixed-12-phase topology.\n\n### Strengths\n- Hand-rolled state machine over a library is the correct choice: 12 phases with a fixed, schema-derived transition table. A state machine library would add dependency weight with zero benefit.\n- Three module-level frozensets (_REVIEW_AXES, _CONSENSUS_GATED, _BLOCKER_GATED, _REVISE_DRIVES_BACK) cleanly capture the gate logic as static data rather than buried conditionals. The code reads declaratively.\n- validate_advance / advance pattern (dry-run + commit) is clean DRY design — no duplication of validation logic.\n- TransitionError with a violations: list[str] attribute is the right API shape: exception for the advance() caller path, list for the validate_advance() path. These are the same violations, just routed differently based on call site.\n- review_votes.clear() on phase transition correctly scopes votes to the phase in which they were cast. This is subtle and correct.\n- DI via optional specs dict is minimal and correct.\n- blocker_count clamped to 0 on decrement is a safe invariant.\n\n### Important Finding\n- aura-plugins-r8m: EpochState.current_role is typed str not RoleId, breaking the strongly-typed enum invariant established by the rest of the design.\n\n### Verdict\nOne IMPORTANT finding (type system inconsistency). No BLOCKER findings. SLICE-2 ACCEPT — the IMPORTANT finding is a follow-up item that does not block correctness.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:23:39Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:23:39Z","labels":["aura:p10-impl:s10-review"]}
{"id":"aura-plugins-0n3","title":"SLICE-2-L3: Impl — EpochStateMachine logic","description":"---\nreferences:\n  slice: aura-plugins-la6\n  impl_plan: aura-plugins-06g\n---\n## Scope\nImplement EpochStateMachine: advance(), validate_advance(), record_vote(), has_consensus(), record_blocker(), available_transitions. Makes L2 tests pass.\n\n## Files Owned\n- scripts/aura_protocol/state_machine.py (fill in implementations)\n\n## Acceptance Criteria\nGiven EpochStateMachine when advance(valid) then transitions correctly, when advance(invalid) then TransitionError raised should never allow invalid transitions","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:39Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:50:55Z","closed_at":"2026-02-22T01:50:55Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-0n3","depends_on_id":"aura-plugins-4mu","type":"blocks","created_at":"2026-02-21T17:32:39Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-0rd","title":"SLICE-4-L3: Impl — ModelId.parse() + event stubs","description":"---\nreferences:\n  slice: aura-plugins-8i5\n  impl_plan: aura-plugins-06g\n---\n## Scope\nImplement ModelId.parse() and finalize event stub types. Makes L2 tests pass.\n\n## Files Owned\n- scripts/aura_protocol/interfaces.py (fill in implementations)\n\n## Acceptance Criteria\nGiven ModelId.parse(\"anthropic/claude-opus-4-6\") when parsed then provider=\"anthropic\" model=\"claude-opus-4-6\" should never accept strings without \"/\"","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:44Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:47:28Z","closed_at":"2026-02-22T01:47:28Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-0rd","depends_on_id":"aura-plugins-exe","type":"blocks","created_at":"2026-02-21T17:32:45Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-0yd","title":"SLICE-3-REVIEW-B-1 MINOR","description":"Reviewer B (Test Quality) — SLICE-3 (constraints.py) minor-level findings.\n\n## Finding: TestCheckAuditTrail builds TransitionRecord objects inline using raw datetime.now() — non-reproducible timestamps may cause rare timing issues on very slow machines (MINOR)\n\nTestCheckAuditTrail tests construct TransitionRecord objects with datetime.now(tz=timezone.utc) inline. In a hermetic test environment this is fine, but if the test suite is run in an environment that mocks or freezes time (e.g., via pytest-freezegun), these tests could fail. A shared TransitionRecord factory fixture with a fixed timestamp would be more robust.\n\n## Finding: TestCheckReviewConsensus.test_violation_message_mentions_consensus uses OR condition — weakens assertion (MINOR)\n\nLine 371:\n    assert 'consensus' in violations[0].message.lower() or 'accept' in violations[0].message.lower()\n\nThe production code message always includes both 'consensus' and 'ACCEPT', so this is overly permissive. Recommend:\n    assert 'consensus' in violations[0].message.lower()\n\nTightening the assertion catches future message regressions more reliably.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:22:03Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:03Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-125","title":"SLICE-2-L1: Types — EpochState, TransitionRecord, TransitionError","description":"---\nreferences:\n  slice: aura-plugins-la6\n  impl_plan: aura-plugins-06g\n---\n## Scope\nDefine the type structure for state_machine.py: EpochState (mutable state), TransitionRecord (frozen audit entry), TransitionError (exception), EpochStateMachine class skeleton with method signatures.\n\n## Files Owned\n- scripts/aura_protocol/state_machine.py (class structure + type definitions only)\n\n## Acceptance Criteria\nGiven state_machine.py when imported then EpochState, TransitionRecord, TransitionError, EpochStateMachine are importable should never have implementations yet (stubs/raise NotImplementedError)","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:38Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:50:54Z","closed_at":"2026-02-22T01:50:54Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"]}
{"id":"aura-plugins-1bm","title":"PROPOSAL-2: bin/aura-release — revised after review","description":"---\nreferences:\n  request: aura-plugins-j2k\n  urd: aura-plugins-99q\n  proposal_1: aura-plugins-wux\n  review_1: aura-plugins-1ey\n---\n\n# PROPOSAL-2: bin/aura-release (revised)\n\nAll BLOCKER and IMPORTANT findings from PROPOSAL-1-REVIEW addressed.\n\n## Changes from PROPOSAL-1\n\n### BLOCKER fixes\n1. **Plugin selection by name**: marketplace.json plugins selected by name==\"aura\" predicate, not array index\n2. **Section-anchored TOML parsing**: Regex anchored to [project] section. Match version= only between [project] header and next [...] header. Alternatively use tomllib (3.11+) for reading with regex replacement for writing (avoids reordering keys)\n3. **--check mode fully defined**:\n   - Standalone: `aura-release --check` (no bump argument required)\n   - Exit 0: all versions consistent\n   - Exit 1: drift detected (prints table of file → version)\n   - --check --sync is invalid (mutual exclusion enforced)\n\n### IMPORTANT fixes\n4. **Pre-defined rollback list**: Before any writes, capture the 3 target files + CHANGELOG.md path in a rollback set. On any failure, git checkout all of them unconditionally\n5. **No prior tag fallback**: If no vX.Y.Z tag exists, changelog includes all commits since initial commit (git rev-list --max-parents=0 HEAD)\n6. **Source of truth explicit**: --sync reads pyproject.toml as canonical version, overwrites plugin.json and marketplace.json to match\n7. **Explicit git add whitelist**: Commit stages exactly: pyproject.toml, .claude-plugin/plugin.json, .claude-plugin/marketplace.json, CHANGELOG.md. Never uses git commit -a or git add .\n\n### MINOR acknowledgments\n8. **Double-bump warning**: If current version != last tag version AND no --sync, warn user and require --force or abort\n9. **UTF-8 encoding**: subprocess.run with encoding=\"utf-8\" for all git log calls\n\n## Architecture\n\n### File: bin/aura-release\n\nSingle Python 3.10+ script, stdlib only.\n\n### Version parsing strategy\n\n```python\n# Read: section-anchored regex\ndef read_pyproject_version(path: Path) -\u003e str:\n    text = path.read_text(encoding=\"utf-8\")\n    # Match version= only within [project] section\n    m = re.search(\n        r\"^\\[project\\]\\s*\\n(?:(?!\\[).*\\n)*?version\\s*=\\s*\\\"(\\d+\\.\\d+\\.\\d+)\\\"\",\n        text, re.MULTILINE\n    )\n    ...\n\n# Write: targeted line replacement within [project] section\ndef write_pyproject_version(path: Path, old: str, new: str) -\u003e None:\n    text = path.read_text(encoding=\"utf-8\")\n    # Replace only the first occurrence after [project]\n    text = text.replace(f'version = \"{old}\"', f'version = \"{new}\"', 1)\n    path.write_text(text, encoding=\"utf-8\")\n```\n\n### marketplace.json plugin selection\n\n```python\ndef update_marketplace(path: Path, new_version: str) -\u003e None:\n    data = json.loads(path.read_text(encoding=\"utf-8\"))\n    data[\"metadata\"][\"version\"] = new_version\n    for plugin in data[\"plugins\"]:\n        if plugin[\"name\"] == \"aura\":\n            plugin[\"version\"] = new_version\n            break\n    path.write_text(json.dumps(data, indent=2) + \"\\n\", encoding=\"utf-8\")\n```\n\n### CLI interface\n\n```\n# Bump version\naura-release \u003cmajor|minor|patch\u003e [--dry-run] [--sync] [--no-changelog] [--no-commit] [--no-tag]\n\n# Check consistency only\naura-release --check\n```\n\nExit codes:\n- 0: success (or --check with consistent versions)\n- 1: --check found drift (prints version table)\n- 2: pre-flight failure (dirty tree, detached HEAD, etc.)\n\n### Workflow\n\n1. Parse args\n2. If --check: read all 3 files, compare versions, exit 0/1\n3. Pre-flight checks:\n   a. Not detached HEAD\n   b. Working tree clean (git status --porcelain, ignore .beads/)\n   c. Read versions from all 3 files\n   d. If versions differ AND --sync not given: exit 2 with error\n   e. If --sync: overwrite plugin.json + marketplace.json to match pyproject.toml\n4. Compute new version from current + bump type\n5. Define rollback set: [pyproject.toml, plugin.json, marketplace.json, CHANGELOG.md]\n6. try:\n   a. Update pyproject.toml (section-anchored replace)\n   b. Update plugin.json (json.load/dump)\n   c. Update marketplace.json (select by name==\"aura\")\n   d. Generate CHANGELOG entry (git log since last vX.Y.Z tag, or since root)\n   e. Prepend to CHANGELOG.md (create if missing)\n   f. If not --no-commit: git add \u003cwhitelist\u003e \u0026\u0026 git commit -m \"chore: release vX.Y.Z\"\n   g. If not --no-tag: git tag -a vX.Y.Z -m \"Release vX.Y.Z\"\n7. except: rollback all files in rollback set via git checkout\n8. Print summary\n\n### CHANGELOG format (Keep a Changelog)\n\n```markdown\n# Changelog\n\n## [0.3.0] - 2026-02-21\n\n### Added\n- feat: some new feature (#commit-short)\n\n### Fixed\n- fix: some bug fix (#commit-short)\n\n### Changed\n- refactor: some refactoring (#commit-short)\n\n### Other\n- chore: some chore (#commit-short)\n```\n\nCommit prefix → section mapping:\n- feat → Added\n- fix → Fixed\n- refactor, perf → Changed\n- docs → Documentation\n- everything else → Other\n\n## Nix integration\n- flake.nix packages auto-wrap bin/* → aura-release included automatically\n- No flake.nix changes needed\n\n## Files\n- bin/aura-release (NEW)\n- CHANGELOG.md (created on first release)","status":"open","priority":2,"issue_type":"feature","assignee":"architect","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:14:01Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:14:01Z","labels":["aura:p3-plan:s3-propose"],"dependencies":[{"issue_id":"aura-plugins-1bm","depends_on_id":"aura-plugins-5sn","type":"blocks","created_at":"2026-02-21T12:19:14Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-1cy","title":"SLICE-4-L1: Types — Protocol interfaces + A2A types + ModelId","description":"---\nreferences:\n  slice: aura-plugins-8i5\n  impl_plan: aura-plugins-06g\n---\n## Scope\nDefine typing.Protocol interfaces (ConstraintValidatorInterface, TranscriptRecorder, SecurityGate, AuditTrail), A2A content types (TextPart, FilePart, DataPart, Part union), ToolCall, ModelId, and event stub types.\n\n## Files Owned\n- scripts/aura_protocol/interfaces.py (type defs)\n\n## Acceptance Criteria\nGiven interfaces.py when imported then all Protocols are runtime_checkable should never require ABC inheritance","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:43Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:47:28Z","closed_at":"2026-02-22T01:47:28Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"]}
{"id":"aura-plugins-1eo","title":"SLICE-5-REVIEW-A-1 BLOCKER","description":"Reviewer A (Correctness) — SLICE-5 (workflow.py) — BLOCKER findings.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:24:51Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:25:00Z","closed_at":"2026-02-22T02:25:00Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-1ey","title":"PROPOSAL-1-REVIEW: Design review findings","description":"---\nreferences:\n  proposal: aura-plugins-wux\n---\n\n## Review Verdict: REVISE (3 BLOCKERs)\n\n### BLOCKERs\n1. marketplace.json plugins must be selected by name==\"aura\", not array index\n2. TOML regex must be section-anchored to [project] block, or use tomllib (3.11+) with fallback\n3. --check mode is undefined (exit codes, interaction with --sync)\n\n### IMPORTANTs\n1. Rollback list must be pre-defined covering all 3 files regardless of write order\n2. \"No prior tag\" fallback for changelog is unspecified\n3. --sync source-of-truth (pyproject.toml) must be explicitly stated\n4. Dirty-tree exception: commit must use explicit git add (whitelist), not git commit -a\n\n### MINORs\n1. --no-commit --no-tag double-bump footgun\n2. Non-ASCII git log needs explicit UTF-8 handling","status":"open","priority":2,"issue_type":"task","assignee":"architect","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:13:25Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:13:25Z","labels":["aura:p4-plan:s4-review"],"dependencies":[{"issue_id":"aura-plugins-1ey","depends_on_id":"aura-plugins-1bm","type":"blocks","created_at":"2026-02-21T12:14:05Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-1ic","title":"SLICE-2-REVIEW-A-1 MINOR","description":"Reviewer A (Correctness) — SLICE-2 (state_machine.py) — MINOR findings.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:53Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:21:53Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"],"dependencies":[{"issue_id":"aura-plugins-1ic","depends_on_id":"aura-plugins-4hu","type":"blocks","created_at":"2026-02-21T18:22:38Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-1ka","title":"SLICE-5-REVIEW-C-1 BLOCKER","description":"Reviewer C (Elegance) — SLICE-5 BLOCKER severity group.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:47Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:58Z","closed_at":"2026-02-22T02:22:58Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-1wg","title":"SLICE-4-REVIEW-A-1 BLOCKER","description":"Reviewer A (Correctness) — SLICE-4 (interfaces.py) — BLOCKER findings.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:23:53Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:24:02Z","closed_at":"2026-02-22T02:24:02Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-20c","title":"SLICE-2-REVIEW-C-1 BLOCKER","description":"Reviewer C (Elegance) — SLICE-2 BLOCKER severity group.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:36Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:57Z","closed_at":"2026-02-22T02:22:57Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-220","title":"REQUEST: Multi-agent orchestration schema-as-runtime with generation pipeline and constraint enforcement","description":"Finding this workflow management untenable. How does LangGraph or LangChain handle these? We need strict schema specification with various constraints upheld, with roles, with shared pieces of context, and also floating pieces of context.\n\nAlso: is the aura:epoch command telling which skills directly to run? We have the skills/protocol/schema.xml that needs to be updated with these rules. Finding this workflow management untenable.\n\n---\n\nContext: The aura protocol has an N-file synchronization problem. schema.xml defines the protocol in BCNF, but the same rules must be restated across SKILL.md files, PROCESS.md, CLAUDE.md, and CONSTRAINTS.md. Every change requires touching 5-7 files manually, and drift is inevitable. We already have some testing and validation occurring via Python. Need to investigate: (1) how frameworks like LangGraph, OpenAI Agents SDK, Microsoft Agent Framework, AgentSpec handle strict schema specification with constraints, roles, shared/floating context; (2) a generation pipeline from schema.xml to downstream files; (3) runtime constraint enforcement.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:58:36Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:58:36Z","labels":["aura:p1-user:s1_1-classify"]}
{"id":"aura-plugins-295","title":"SLICE-1-REVIEW-B-1 IMPORTANT","description":"Reviewer B (Test Quality) — SLICE-1 (types.py / __init__.py) important-level findings.\n\n## Finding: Mutation test uses bare 'except Exception' — insufficient specificity (IMPORTANT)\n\nIn test_aura_types.py (TestSpecFreezing), the freezing tests use a bare:\n\n    with pytest.raises(Exception):\n        t.condition = 'mutate'\n\nPython frozen dataclasses raise dataclasses.FrozenInstanceError (a subclass of AttributeError). Using pytest.raises(Exception) accepts ANY exception, including ones that could mask a real bug (e.g. NameError, TypeError from a different code path). The tests would still pass even if the field name was wrong and raised AttributeError for a different reason.\n\nRecommendation: Use pytest.raises((dataclasses.FrozenInstanceError, AttributeError)) or simply pytest.raises(AttributeError) to narrow the exception type. This follows the principle of testing observable outcomes precisely.\n\nThis is IMPORTANT (not BLOCKER) because the tests do pass and the production code IS frozen; this is an imprecision in the test assertion specificity only.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:37Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:20:37Z","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-2au","title":"SLICE-5-L3: Impl — EpochWorkflow + activities","description":"---\nreferences:\n  slice: aura-plugins-lkz\n  impl_plan: aura-plugins-06g\n---\n## Scope\nImplement EpochWorkflow (run, advance_phase, submit_vote, current_state, available_transitions) and activities (check_constraints, record_transition). Makes L2 tests pass.\n\n## Files Owned\n- scripts/aura_protocol/workflow.py (fill in implementations)\n\n## Acceptance Criteria\nGiven EpochWorkflow when advance_phase signal received then state transitions + search attrs updated atomically should never have non-deterministic operations","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:47Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:17:12Z","closed_at":"2026-02-22T02:17:12Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-2au","depends_on_id":"aura-plugins-amx","type":"blocks","created_at":"2026-02-21T17:32:47Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-2tj","title":"FOLLOWUP: Non-blocking improvements from aura_protocol v1 code review","description":"---\nreferences:\n  request: aura-plugins-bj1\n  urd: aura-plugins-umi\n  review_round: aura-plugins-e0j\n---\n## Aggregated IMPORTANT and MINOR findings from code review round 1.\n\n### IMPORTANT Findings (11 total across 3 reviewers)\n\n#### Reviewer A\n1. aura-plugins-ipj (SLICE-2): Timestamp coupling — advance() creates TransitionRecord with datetime.now(), workflow post-hoc mutates. Fix: pass timestamp param.\n2. aura-plugins-jwb (SLICE-3): check_severity_tree() missing C-severity-eager positive enforcement (p10 MUST have 3 groups). EpochState needs severity_groups field.\n3. aura-plugins-zpu (SLICE-4): TYPE_CHECKING Protocol implications undocumented — isinstance checks only method name presence.\n4. aura-plugins-6wg (SLICE-5): Bare except Exception in EpochWorkflow.run() catches unexpected errors. Should be except TransitionError.\n\n#### Reviewer B\n5. aura-plugins-yno (SLICE-3): check_all() only aggregates 5 of 22 constraint methods.\n6. aura-plugins-o83 (SLICE-2): P10→P11 consensus enforcement split between state_machine and constraints layers — undocumented architectural decision.\n7. aura-plugins-5zf (SLICE-4): No test verifying RuntimeConstraintChecker satisfies ConstraintValidatorInterface Protocol.\n8. aura-plugins-68o (SLICE-5): No WorkflowEnvironment.start_time_skipping() integration test.\n\n#### Reviewer C\n9. aura-plugins-r8m (SLICE-2): EpochState.current_role typed str not RoleId.\n10. aura-plugins-in8 (SLICE-3): check_severity_tree() incomplete (same as A's finding).\n11. aura-plugins-i2g (SLICE-5): Bare except + no audit of failed transitions (same concern as A's finding).\n\n### MINOR Findings (8+ across 3 reviewers)\nReferenced in individual severity group tasks.","status":"open","priority":3,"issue_type":"epic","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:27:27Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:27:27Z","labels":["aura:epic-followup"],"dependencies":[{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-0yd","type":"blocks","created_at":"2026-02-21T18:27:33Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-1ic","type":"blocks","created_at":"2026-02-21T18:27:31Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-295","type":"blocks","created_at":"2026-02-21T18:27:28Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-3xe","type":"blocks","created_at":"2026-02-21T18:27:28Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-4u1","type":"blocks","created_at":"2026-02-21T18:27:33Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-5zf","type":"blocks","created_at":"2026-02-21T18:27:29Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-68o","type":"blocks","created_at":"2026-02-21T18:27:30Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-7d2","type":"blocks","created_at":"2026-02-21T18:27:32Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-7no","type":"blocks","created_at":"2026-02-21T18:27:34Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-8jy","type":"blocks","created_at":"2026-02-21T18:27:32Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-947","type":"blocks","created_at":"2026-02-21T18:27:30Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-bnr","type":"blocks","created_at":"2026-02-21T18:27:27Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-don","type":"blocks","created_at":"2026-02-21T18:27:30Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-dvi","type":"blocks","created_at":"2026-02-21T18:27:31Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-gdx","type":"blocks","created_at":"2026-02-21T18:27:31Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-h7x","type":"blocks","created_at":"2026-02-21T18:27:34Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-j02","type":"blocks","created_at":"2026-02-21T18:27:36Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-ngd","type":"blocks","created_at":"2026-02-21T18:27:28Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-o83","type":"blocks","created_at":"2026-02-21T18:27:29Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-pxo","type":"blocks","created_at":"2026-02-21T18:27:34Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-sk6","type":"blocks","created_at":"2026-02-21T18:27:34Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-tcn","type":"blocks","created_at":"2026-02-21T18:27:27Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-utj","type":"blocks","created_at":"2026-02-21T18:27:35Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-v1b","type":"blocks","created_at":"2026-02-21T18:27:33Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-x36","type":"blocks","created_at":"2026-02-21T18:27:35Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-xui","type":"blocks","created_at":"2026-02-21T18:27:32Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-2tj","depends_on_id":"aura-plugins-yno","type":"blocks","created_at":"2026-02-21T18:27:29Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-35d","title":"SLICE-1: types.py — Protocol type definitions","description":"---\nreferences:\n  impl_plan: aura-plugins-06g\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n---\n## Specification\nDefine all typed enums and frozen dataclass specs for the aura protocol. This is the foundation module imported by all others.\n\n### Key Types\n- PhaseId (13 values: p1-p12 + complete)\n- Domain (user, plan, impl)\n- RoleId (epoch, architect, reviewer, supervisor, worker)\n- VoteType (ACCEPT, REVISE)\n- SeverityLevel (BLOCKER, IMPORTANT, MINOR)\n- PhaseSpec, Transition, ConstraintSpec, HandoffSpec (frozen dataclasses)\n- PHASE_SPECS, CONSTRAINT_SPECS, HANDOFF_SPECS (canonical lookup dicts)\n- PHASE_DOMAIN mapping\n\n### Also\n- Create scripts/aura_protocol/__init__.py with public API re-exports\n- Event stub types: PhaseTransitionEvent, ConstraintCheckEvent, ReviewVoteEvent, AuditEvent, ToolPermissionRequest, PermissionDecision\n\n## Files Owned\n- scripts/aura_protocol/__init__.py (NEW)\n- scripts/aura_protocol/types.py (NEW)\n- tests/test_aura_types.py (NEW)\n- tests/test_schema_types_sync.py (NEW)\n\n## Acceptance Criteria\n- AC8: Given Python type definitions when compared against schema.xml then every PhaseId, Domain, RoleId matches schema.xml should never drift\n- All enums are str Enums for JSON/Temporal serialization\n- All spec dataclasses are frozen (immutable)\n- PHASE_DOMAIN mapping matches schema.xml _EXPECTED_DOMAINS\n\n## Validation Checklist\n- [ ] Types defined (enums + frozen dataclasses)\n- [ ] Tests written (test_aura_types.py + test_schema_types_sync.py)\n- [ ] __init__.py with re-exports\n- [ ] All 13 PhaseId values present\n- [ ] PHASE_SPECS covers all 12 phases\n- [ ] Integration test verifies Python types match schema.xml","design":"{\"validation_checklist\":[\"PhaseId matches schema.xml\",\"Domain matches DomainType enum\",\"RoleId matches schema.xml\",\"PHASE_DOMAIN mapping correct\",\"All specs are frozen\",\"str Enums for serialization\"],\"acceptance_criteria\":[{\"given\":\"Python types.py\",\"when\":\"compared to schema.xml\",\"then\":\"all enums match\",\"should_not\":\"drift from schema.xml\"}],\"ratified_plan\":\"aura-plugins-gmv\"}","status":"closed","priority":2,"issue_type":"task","assignee":"worker-1","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:31:28Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:42:54Z","closed_at":"2026-02-22T01:42:54Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-35d","depends_on_id":"aura-plugins-9nc","type":"blocks","created_at":"2026-02-21T17:32:36Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-35d","depends_on_id":"aura-plugins-btb","type":"blocks","created_at":"2026-02-21T18:23:23Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-35d","depends_on_id":"aura-plugins-g2a","type":"blocks","created_at":"2026-02-21T17:32:37Z","created_by":"David Huu Pham","metadata":"{}"}],"comments":[{"id":10,"issue_id":"aura-plugins-35d","author":"David Huu Pham","text":"SLICE-1 complete. All 65 tests pass (49 unit tests in test_aura_types.py + 16 integration tests in test_schema_types_sync.py). Existing validate_schema tests pass with no regressions (95 passing). Files created: scripts/aura_protocol/__init__.py, scripts/aura_protocol/types.py, tests/test_aura_types.py, tests/test_schema_types_sync.py.","created_at":"2026-02-22T01:42:07Z"},{"id":21,"issue_id":"aura-plugins-35d","author":"David Huu Pham","text":"VOTE: ACCEPT - SLICE-1 (types.py + __init__.py) is correct. All 13 PhaseId values present; 12 in PHASE_SPECS (COMPLETE correctly excluded); PHASE_DOMAIN covers all 12 phases with correct domain assignments; all 22 C-* constraints codified as ConstraintSpec with complete Given/When/Then/Should-not fields; 6 HandoffSpec entries; all enums are str Enums for JSON/Temporal serialization; all spec dataclasses are frozen. __init__.py re-exports are complete and accurate. AC8 (schema-types sync) is fully addressed by test_schema_types_sync.py which does direct XML parsing validation. No correctness issues found.","created_at":"2026-02-22T02:21:47Z"},{"id":23,"issue_id":"aura-plugins-35d","author":"David Huu Pham","text":"VOTE: ACCEPT (Reviewer B - Test Quality)\n\nSLICE-1 (types.py / __init__.py): Tests are well-structured with correct imports from production modules. SUT is not mocked. Tests verify observable outcomes (enum membership, JSON serialization, FrozenInstanceError, PHASE_DOMAIN correctness, PHASE_SPECS structural invariants). test_schema_types_sync.py is an excellent integration test that parses real schema.xml to prevent drift. \n\nSeverity groups: aura-plugins-ye3 (BLOCKER, empty/closed), aura-plugins-295 (IMPORTANT: exception type specificity in freeze tests), aura-plugins-8jy (MINOR: _make_state kwargs opacity, hardcoded constraint subset).\nNo BLOCKERs. ACCEPT.","created_at":"2026-02-22T02:23:27Z"}]}
{"id":"aura-plugins-3m4","title":"SLICE-5-REVIEW-C-1-F1: Workflow reassigns frozen TransitionRecord in transition_history list — breaks expected immutability guarantee","description":"## Finding\n\nIn workflow.py (lines 284-285), after the advance() call produces a TransitionRecord, the workflow replaces the last entry in transition_history with a new record using workflow.now():\n\n    if self._sm.state.transition_history:\n        self._sm.state.transition_history[-1] = deterministic_record\n\nTransitionRecord is documented as 'Immutable audit entry for one transition' and is a frozen=True dataclass. The list itself (transition_history) is mutable (EpochState.transition_history: list[TransitionRecord]), so replacing the list entry is structurally legal in Python.\n\nHowever, this pattern is unexpected and subtle:\n1. The comment in advance() says 'Records the transition in transition_history' — the record written there has a non-deterministic datetime.now() timestamp\n2. The workflow then silently overwrites the last record with a deterministic timestamp\n3. Callers who query current_state() before the overwrite step (very unlikely in practice due to Temporal's scheduling, but possible) would see the non-deterministic timestamp\n4. This is the only place in the entire codebase where a list element is reassigned post-hoc\n\n## Alternative\nModify EpochStateMachine.advance() to accept an optional timestamp parameter:\n    def advance(self, to_phase, *, triggered_by, condition_met, timestamp=None):\n        ts = timestamp or datetime.now(tz=timezone.utc)\n        record = TransitionRecord(..., timestamp=ts)\n\nThe workflow passes workflow.now() directly; pure Python tests pass nothing (defaults to datetime.now()). This eliminates the post-hoc mutation entirely.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:22:49Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:49Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-3r4","title":"FIX: UAT revisions — constraints API split + interfaces runtime imports","description":"---\nreferences:\n  impl_plan: aura-plugins-06g\n  urd: aura-plugins-umi\n  review_round: aura-plugins-e0j\n---\n## UAT Revision Requests (verbatim)\n\n### 1. Split check_all() into two APIs\nUser chose: \"Rename check_all() to check_state_constraints() and add check_transition_constraints(state, to_phase) that combines transition-specific checks. Two clear entry points.\"\n\nChanges needed:\n- constraints.py: Rename check_all() → check_state_constraints()\n- constraints.py: Add check_transition_constraints(state, to_phase) that combines transition-specific checks\n- Keep individual check methods intact\n- Update __init__.py re-exports if needed\n- Update test_constraints.py to test new API\n\n### 2. Use runtime imports in Protocol interfaces\nUser chose: \"Change to real runtime imports even though it creates tighter coupling. Full isinstance() fidelity at the cost of potential circular imports.\"\n\nChanges needed:\n- interfaces.py: Change TYPE_CHECKING imports to real runtime imports\n- Verify no circular import issues\n- Update test_interfaces.py if needed\n\n## Files to Modify\n- scripts/aura_protocol/constraints.py\n- scripts/aura_protocol/interfaces.py\n- scripts/aura_protocol/__init__.py (if re-exports change)\n- tests/test_constraints.py\n- tests/test_interfaces.py (if needed)","status":"in_progress","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:59:44Z","created_by":"David Huu Pham","updated_at":"2026-02-22T03:00:12Z","labels":["aura:p11-user:s11-uat","aura:p9-impl:s9-slice"]}
{"id":"aura-plugins-3xe","title":"SLICE-5-REVIEW-A-1 IMPORTANT","description":"Reviewer A (Correctness) — SLICE-5 (workflow.py) — IMPORTANT findings.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:24:51Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:24:51Z","labels":["aura:p10-impl:s10-review","aura:severity:important"],"dependencies":[{"issue_id":"aura-plugins-3xe","depends_on_id":"aura-plugins-6wg","type":"blocks","created_at":"2026-02-21T18:25:21Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-4hu","title":"SLICE-2-REVIEW-A-1 MINOR: EpochState.current_role type is str not RoleId","description":"## Finding\n\n### Location\n`scripts/aura_protocol/state_machine.py`, line 47:\n```python\ncurrent_role: str = 'epoch'\n```\n\n### Description\nThe proposal (RATIFIED_PLAN aura-plugins-gmv) defines `EpochState.current_role` as type `RoleId` (typed enum). The implementation declares it as plain `str`.\n\n```python\n# Proposal spec:\ncurrent_role: RoleId\n\n# Implementation:\ncurrent_role: str = 'epoch'\n```\n\n### Consequence\n- No type-safety guarantee that current_role is a valid RoleId value\n- RuntimeConstraintChecker.check_role_ownership() correctly compensates by checking `state.current_role not in known_roles` (a set of str values), but this is defensive coding around a typing gap\n- Consumers of EpochState.current_role cannot rely on IDE autocomplete or static type checking for the enum variants\n\n### Severity\nMINOR — the runtime behaviour is correct because check_role_ownership() enforces validity, and str is compatible with RoleId.value. No functional bug exists. This is a type annotation gap relative to the proposal spec.\n\n### Suggestion\nChange to `current_role: RoleId = RoleId.EPOCH` to match the proposal spec and gain full type safety. Update any callers that pass plain strings (the workflow currently sets via signal, so no breaking change to public API).","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:22:35Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:35Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-4mu","title":"SLICE-2-L2: Tests — test_state_machine.py (AC1-AC4)","description":"---\nreferences:\n  slice: aura-plugins-la6\n  impl_plan: aura-plugins-06g\n---\n## Scope\nWrite test_state_machine.py covering AC1 (transitions), AC2 (consensus gate), AC3 (revision loop), AC4 (BLOCKER gate). Tests import from state_machine.py and WILL FAIL until L3 implementation.\n\n## Files Owned\n- tests/test_state_machine.py\n\n## Acceptance Criteria\nGiven test_state_machine.py when run before L3 then tests fail (expected) should never pass without real implementation","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:38Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:50:54Z","closed_at":"2026-02-22T01:50:54Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-4mu","depends_on_id":"aura-plugins-125","type":"blocks","created_at":"2026-02-21T17:32:39Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-4ou","title":"SLICE-1-REVIEW-A-1 IMPORTANT: CONSTRAINT_SPECS count in __init__.py docstring says 22 but not verified","description":"## Finding\n\nIn `scripts/aura_protocol/__init__.py` the module docstring says:\n\u003e RuntimeConstraintChecker — checks all 22 C-* constraints against epoch state\n\nThe number 22 is also stated in constraints.py module docstring. However, CONSTRAINT_SPECS in types.py has exactly 22 entries (verified by counting). This is correct.\n\nActually reviewing more carefully: the __init__.py comment says '13 values: p1-p12 + complete' for PhaseId which is accurate (12 numbered + 1 COMPLETE = 13). This is also correct.\n\nRESOLUTION: After detailed re-read, SLICE-1 has no IMPORTANT findings. All types, counts, and docstrings are accurate and consistent with the schema.\n\n**No finding — group to be closed.**","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:31Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:21:38Z","closed_at":"2026-02-22T02:21:38Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-4u1","title":"SLICE-4-REVIEW-B-1 MINOR","description":"Reviewer B (Test Quality) — SLICE-4 (interfaces.py) minor-level findings.\n\n## Finding: TestToolCall.test_tool_call_is_hashable documents that ToolCall with dict fields is NOT hashable via a pytest.raises(TypeError) assertion — this is a surprising test (MINOR)\n\nThe test at test_interfaces.py lines 374-380 explicitly tests that hash(ToolCall(...)) raises TypeError. While this documents a known limitation, it's unusual to write a test that asserts an operation FAILS as expected behavior. The test is named 'test_tool_call_is_hashable' but actually documents the opposite. This could confuse future contributors.\n\nRecommend renaming to 'test_tool_call_with_dict_fields_is_not_hashable' and adding a comment explaining why (frozen dataclass with mutable dict fields loses hash). This is a naming clarity issue only.\n\n## Finding: No test verifies ModelId.parse raises ValueError for strings with only whitespace around the slash (MINOR)\n\nTests cover empty string, leading slash, trailing slash, slash only. However '  /model' or 'provider/  ' (whitespace around separator) are not tested. The production code would parse these as provider=' ' and model='model' (no error). Whether this is correct behavior is undefined in the spec. A minor clarification or test would document the decision.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:22:36Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:36Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-5s5","title":"SLICE-3-REVIEW-A-1 BLOCKER","description":"Reviewer A (Correctness) — SLICE-3 (constraints.py) — BLOCKER findings.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:22:52Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:23:02Z","closed_at":"2026-02-22T02:23:02Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-5sn","title":"UAT-1: Plan acceptance for release automation PROPOSAL-2","description":"---\nreferences:\n  proposal: aura-plugins-1bm\n---\n\n## UAT Result: ACCEPT\n\nUser accepted PROPOSAL-2 design for bin/aura-release.\nNo revision feedback provided.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:19:14Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:19:14Z","labels":["aura:p5-user:s5-uat"],"dependencies":[{"issue_id":"aura-plugins-5sn","depends_on_id":"aura-plugins-bch","type":"blocks","created_at":"2026-02-21T12:19:27Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-5zf","title":"SLICE-4-REVIEW-B-1 IMPORTANT","description":"Reviewer B (Test Quality) — SLICE-4 (interfaces.py) important-level findings.\n\n## Finding: ConstraintValidatorInterface.validate() type annotation uses forward references (EpochState, ConstraintViolation) hidden behind TYPE_CHECKING — isinstance() test with inline ConcreteValidator returns True even though the type signatures differ (IMPORTANT)\n\nIn interfaces.py, the Protocol uses:\n    from aura_protocol.constraints import ConstraintViolation  (TYPE_CHECKING only)\n    from aura_protocol.state_machine import EpochState         (TYPE_CHECKING only)\n\nThe Protocol method signature is:\n    def validate(self, state: EpochState) -\u003e list[ConstraintViolation]: ...\n\nAt runtime (non-TYPE_CHECKING), EpochState and ConstraintViolation are NOT available as types in the Protocol method signature. Python's runtime_checkable only checks method PRESENCE, not signatures. The test:\n\n    class ConcreteValidator:\n        def validate(self, state: object) -\u003e list:  # different type annotations\n            return []\n    assert isinstance(ConcreteValidator(), ConstraintValidatorInterface)  # True\n\nThis PASSES, which is correct Python behavior for @runtime_checkable. However, the test does not verify that the production RuntimeConstraintChecker (the intended implementor of this protocol) would itself satisfy isinstance(checker, ConstraintValidatorInterface).\n\nRecommendation: Add a test that verifies isinstance(RuntimeConstraintChecker(), ConstraintValidatorInterface). This is the AC9 integration test that closes the loop between the Protocol definition and its actual production implementor.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:22:26Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:26Z","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-68o","title":"SLICE-5-REVIEW-B-1 IMPORTANT","description":"Reviewer B (Test Quality) — SLICE-5 (workflow.py) important-level findings.\n\n## Finding: No full end-to-end Temporal sandbox test — WorkflowEnvironment.start_time_skipping() tests are absent — AC6 and AC7 are tested via state machine integration only, not via actual Temporal signal delivery (IMPORTANT)\n\nThe test file explicitly documents this limitation in the module docstring:\n  'When a Temporal server is available, full end-to-end sandbox tests should use WorkflowEnvironment.start_time_skipping() with the EpochWorkflow class.'\n\nThe proposal (AC6, AC7) describes Temporal-specific behavior:\n  - AC6: 'advance_phase signal is received → state machine transitions and search attributes are updated atomically'\n  - AC7: 'querying Temporal with filter AuraPhase=p9 → the workflow is returned in results'\n\nThe current tests verify that the LOGIC is correct (state machine integration tests) and that the STRUCTURE is correct (decorator introspection). They do NOT verify that:\n1. The workflow's signal handler actually calls sm.advance() correctly (the wire-up is untested end-to-end).\n2. workflow.upsert_search_attributes() is called with the correct values after a signal (search attr freshness is untested).\n3. The workflow correctly drains the pending signal queue before advancing (the pending_*_signals pattern in EpochWorkflow.run() is untested).\n\nRecommendation: Once a Temporal dev server binary is available in CI (via docker or pre-downloaded), add WorkflowEnvironment.start_time_skipping() tests for at least:\n  - One full advance_phase signal → state transition → search attribute update path\n  - One submit_vote signal → has_consensus() path\n\nThis should be tracked as a follow-up epic item. The current tests are a pragmatic v1 solution, not a permanent architecture.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:23:01Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:23:01Z","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-6wg","title":"SLICE-5-REVIEW-A-1 IMPORTANT: bare except Exception swallows TransitionError without distinguishing constraint vs protocol violation","description":"## Finding\n\n### Location\n`scripts/aura_protocol/workflow.py`, `run()` method, lines 263-272:\n\n```python\ntry:\n    record = self._sm.advance(\n        advance_signal.to_phase,\n        triggered_by=advance_signal.triggered_by,\n        condition_met=advance_signal.condition_met,\n    )\nexcept Exception:\n    # TransitionError from invalid advance — skip, stay in current phase.\n    # The violation is already counted from the constraint check.\n    continue\n```\n\n### Description\nThe bare `except Exception:` catches ALL exceptions, not just `TransitionError`. This means:\n\n1. **Unexpected exceptions** (e.g., MemoryError, RuntimeError, AttributeError from a bug in state_machine.py) are silently swallowed, the workflow continues in the current phase without any indication that something went wrong.\n\n2. **Violation double-counting gap:** The comment says 'The violation is already counted from the constraint check.' But the constraint check (check_constraints activity) and the state machine's validate_advance() check overlapping but NOT identical conditions. The constraint checker checks C-* constraints; the state machine checks the transition table. A state machine TransitionError for an invalid target (not in PHASE_SPECS transition table at all) would be caught here but the constraint activity may NOT have returned violations for it (check_transition only checks consensus and handoff, not the full table).\n\n3. **Silent failure mode:** An invalid advance signal (e.g., a to_phase not in the transition table from the current phase) silently drops the signal. The workflow user has no way to know the signal was rejected unless they poll current_state(). There is no error signal or result returned to the signal sender.\n\n### Risk\nIMPORTANT (not BLOCKER) because: (1) in the happy path and even in the error path the workflow continues running; (2) the violation counter is not the primary user-facing indicator; (3) AC6 tests pass. However, silent failure of advance signals is a significant correctness concern for production use.\n\n### Suggestion\nChange to `except TransitionError as e:` to make the intent explicit and not swallow unexpected exceptions:\n```python\nexcept TransitionError:\n    # Invalid advance — stay in current phase.\n    # Violation was already counted from constraint check activity.\n    continue\n```\nThis allows unexpected exceptions to propagate and fail the workflow with a proper error, rather than silently continuing.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:25:18Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:25:18Z","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-6yr","title":"SLICE-2: Fix CLI UX error messages in bin/aura-release","description":"---\nreferences:\n  uat: aura-plugins-nfr\n  impl_plan: aura-plugins-bch\n---\n\n## Specification\n\nFix 4 UX issues identified during UAT-2 in bin/aura-release error messages.\n\n## Files Owned\n- bin/aura-release (lines ~430-465: CLI/main, lines ~305-341: cmd_release pre-flight, lines ~286-302: cmd_check)\n\n## Issues to Fix\n\n### Issue 1: No-args error message needs actionable examples\n**Current (line 459):**\n  bump type required (major, minor, or patch). Use --check for consistency validation.\n**Required:** Show example commands:\n  aura-release patch           # bump patch version\n  aura-release minor           # bump minor version\n  aura-release --check         # check version consistency\n  aura-release patch --dry-run # preview changes\n\n### Issue 2: Drift error needs to suggest exact fix command\n**Current (lines 337-340):**\n  Error: version drift detected:\n    pyproject.toml: 0.2.2\n    ...\n  Use --sync to align before bumping.\n**Required:** Show the exact command the user should run, e.g.:\n  Try: aura-release \u003cbump\u003e --sync\n  (where \u003cbump\u003e is the bump_kind the user already passed)\n\n### Issue 3: --sync should explain what needs to be clean\n**Current (lines 321-324):**\n  Error: working tree has uncommitted changes (outside .beads/).\n  Commit or stash them first.\n**Required:** Briefly explain WHAT needs to be clean: tracked files outside .beads/ must have no uncommitted changes. The .beads/ directory is always excluded from the clean-tree check.\n\n### Issue 4: Overall — all error paths should guide user to next action\nEvery error exit should end with a concrete \"Try: ...\" or \"Next: ...\" suggestion.\n\n## Acceptance Criteria\nGiven a user runs aura-release with no args, when they see the error, then the message shows example commands they can copy-paste.\nGiven a user runs aura-release patch and versions are drifted, when they see the drift error, then the message shows the exact command with --sync to fix it.\nGiven a user runs aura-release and the working tree is dirty, when they see the error, then the message explains what files need to be clean.","status":"open","priority":2,"issue_type":"task","assignee":"worker-1","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:31:06Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:31:06Z","labels":["aura:p9-impl:s9-slice"],"comments":[{"id":1,"issue_id":"aura-plugins-6yr","author":"David Huu Pham","text":"SLICE-2 complete. All 4 UX error message fixes verified: (1) no-args shows usage examples, (2) drift error shows exact command with --sync, (3) dirty tree explains what needs to be clean, (4) detached HEAD shows git checkout suggestion.","created_at":"2026-02-21T20:32:40Z"}]}
{"id":"aura-plugins-7d2","title":"SLICE-4-REVIEW-A-1 MINOR","description":"Reviewer A (Correctness) — SLICE-4 (interfaces.py) — MINOR findings.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:23:54Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:23:54Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"],"dependencies":[{"issue_id":"aura-plugins-7d2","depends_on_id":"aura-plugins-hls","type":"blocks","created_at":"2026-02-21T18:24:36Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-7gm","title":"PROPOSAL-1-REVIEW-A-1: aura protocol engine v1","description":"VOTE: ACCEPT - The proposal faithfully serves the user's original request across all 8 URD requirements. R1 (machine-executable protocol) is the core deliverable and is thoroughly addressed with 5 well-scoped modules. R2-R3 are correctly deferred to v2/v3 per the user's explicit 3-version roadmap. R4-R8 are addressed proportionally to v1 scope.\n\n## Correctness Findings\n\n### Transition Table Design\nThe 12-phase transition table is derived directly from schema.xml transitions. Forward transitions, revision loops (p4-\u003ep3, p10-\u003ep9, p5-\u003ep3, p11-\u003ep9), and the terminal p12-\u003ecomplete are all accounted for. The PhaseId.COMPLETE sentinel correctly represents the terminal state without a corresponding PhaseSpec. The integration test (test_schema_types_sync.py) is a strong safeguard against type drift.\n\n### Temporal Integration\nSignals for mutations (advance_phase, submit_vote), queries for reads (current_state, available_transitions), search attributes for forensics (5 typed keys), and activities for I/O (check_constraints, record_transition) — all follow correct Temporal patterns. Determinism is preserved by keeping workflow code side-effect-free with all I/O in activities.\n\n### Engineering Tradeoffs\nAll 8 tradeoffs are well-justified and internally consistent: hand-rolled SM for fixed topology, one workflow per epoch for v1 simplicity, dataclasses for Temporal SDK compatibility, typing.Protocol for structural subtyping across repo boundaries, scripts/ package location matching existing pythonpath.\n\n### Review Consensus and BLOCKER Gates\nAC2 (consensus requires 3 ACCEPT votes) and AC4 (BLOCKER count \u003e 0 blocks p10-\u003ep11) correctly model the schema.xml constraints C-review-consensus and the p10 transition condition \"all 3 reviewers ACCEPT, all BLOCKERs resolved.\"\n\n### Minor Observations (Non-Blocking)\n1. A2A TaskState enum is mentioned in the URD (R5) and tradeoff table but not included in the module definitions. PhaseId covers lifecycle states, so this is not a functional gap, but should be tracked for A2A compliance completeness.\n2. EpochState uses set[PhaseId] and dict[str, VoteType] which will need Temporal serialization handling — this is an implementation detail, not a design flaw, and will be caught by test_workflow.py integration tests.\n3. The proposal could explicitly state how the follow-up lifecycle (schema.xml followup-lifecycle section) maps to the state machine — whether FOLLOWUP_* phases reuse the same EpochStateMachine or create a new instance. This does not block v1 since follow-up is triggered after code review, but clarifying the design intent would help implementers.\n\n### Verdict\nAll 6 end-user alignment criteria satisfied. No BLOCKER issues. The proposal is technically consistent with its stated rationale, faithfully addresses the URD requirements within v1 scope, and the public interfaces are sufficient for the MVP goals.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:00:16Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:00:16Z","labels":["aura:p4-plan:s4-review"]}
{"id":"aura-plugins-7iy","title":"SLICE-4-REVIEW-C-1: interfaces.py — Integration interfaces and A2A types","description":"VOTE: ACCEPT\n\n## Review Summary (Reviewer C — Elegance and Complexity Proportionality)\n\nSLICE-4 (interfaces.py) is the most externally-facing slice and the design is proportionate to v1 scope.\n\n### Strengths\n- typing.Protocol + @runtime_checkable is the correct choice for cross-repo structural subtyping. External repos (unified-schema, agentfilter) implement the interface without any dependency on aura-plugins' class hierarchy. This is exactly the right use of structural subtyping.\n- The 4 Protocols (ConstraintValidatorInterface, TranscriptRecorder, SecurityGate, AuditTrail) map cleanly to the 4 external system boundaries defined in the URD. No extra interfaces speculating on future needs.\n- TYPE_CHECKING guard for ConstraintViolation and EpochState imports avoids circular imports at runtime while keeping the method signatures fully typed. Clean Python idiom.\n- TextPart / FilePart / DataPart as a Part union type alias is the minimal A2A content type hierarchy for v1 — correct scoping. Full hierarchy is explicitly deferred to v2/v3.\n- ModelId.parse() using str.partition('/') splits on the first '/' only, correctly handling org/team/model formats. The error message is specific and actionable.\n- The re-export of event stub types from interfaces.py (in __all__) allows callers to import all integration-related types from one place. Good ergonomics.\n\n### Minor Finding\n- aura-plugins-eqy: DataPart.data, ToolCall.tool_input, ToolCall.tool_output typed as bare dict — should be dict[str, Any] for consistency with the rest of the typed codebase.\n\n### Verdict\nNo BLOCKER or IMPORTANT findings. One MINOR finding. SLICE-4 ACCEPT.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:24:15Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:24:15Z","labels":["aura:p10-impl:s10-review"]}
{"id":"aura-plugins-7no","title":"SLICE-2-REVIEW-C-1 MINOR","description":"Reviewer C (Elegance) — SLICE-2 MINOR severity group.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:37Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:23:04Z","closed_at":"2026-02-22T02:23:04Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-80v","title":"SLICE-1-REVIEW-A-1 IMPORTANT","description":"Reviewer A (Correctness) — SLICE-1 (types.py, __init__.py) — IMPORTANT findings.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:09Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:21:38Z","closed_at":"2026-02-22T02:21:38Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-8be","title":"SLICE-4-REVIEW-C-1 BLOCKER","description":"Reviewer C (Elegance) — SLICE-4 BLOCKER severity group.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:46Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:58Z","closed_at":"2026-02-22T02:22:58Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-8i5","title":"SLICE-4: interfaces.py — Cross-project integration + A2A types","description":"---\nreferences:\n  impl_plan: aura-plugins-06g\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n---\n## Specification\nPython Protocol interfaces for cross-project integration + A2A-compatible content types. Uses structural subtyping (typing.Protocol, runtime_checkable).\n\n### Protocol Interfaces\n- ConstraintValidatorInterface — validate(state) -\u003e list[ConstraintViolation]\n- TranscriptRecorder — record phase transitions, constraint checks, review votes\n- SecurityGate — check tool permissions\n- AuditTrail — record and query audit events\n\n### A2A Content Types (minimal v1 subset)\n- TextPart, FilePart, DataPart (frozen dataclasses)\n- Part = TextPart | FilePart | DataPart (union type)\n- ToolCall (MCP-compatible tool call representation)\n- ModelId (models.dev {provider}/{model} composite identifier)\n\n### Event Stub Types (frozen dataclasses)\n- PhaseTransitionEvent, ConstraintCheckEvent, ReviewVoteEvent\n- AuditEvent, ToolPermissionRequest, PermissionDecision\n\n## Files Owned\n- scripts/aura_protocol/interfaces.py (NEW)\n- tests/test_interfaces.py (NEW)\n\n## Acceptance Criteria\n- AC9: Given class implementing Protocol when isinstance() checked then True should not require subclassing\n- AC10: Given ModelId.parse(\"anthropic/claude-opus-4-6\") when parsed then provider=\"anthropic\" model=\"claude-opus-4-6\" should not accept strings without \"/\"\n\n## Validation Checklist\n- [ ] All Protocol interfaces are runtime_checkable\n- [ ] A2A Part union covers 3 types\n- [ ] ModelId.parse() validates format\n- [ ] Event stub types defined\n- [ ] Tests cover AC9 + AC10","design":"{\"validation_checklist\":[\"Protocol interfaces runtime_checkable\",\"Part union complete\",\"ModelId validates format\",\"Event stubs defined\"],\"acceptance_criteria\":[{\"given\":\"Protocol implementor\",\"when\":\"isinstance checked\",\"then\":\"returns True\",\"should_not\":\"require subclassing\"},{\"given\":\"ModelId.parse(valid)\",\"when\":\"parsed\",\"then\":\"correct provider and model\",\"should_not\":\"accept invalid format\"}],\"ratified_plan\":\"aura-plugins-gmv\"}","status":"closed","priority":2,"issue_type":"task","assignee":"worker-4","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:31:29Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:47:29Z","closed_at":"2026-02-22T01:47:29Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-8i5","depends_on_id":"aura-plugins-0rd","type":"blocks","created_at":"2026-02-21T17:32:44Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-8i5","depends_on_id":"aura-plugins-1cy","type":"blocks","created_at":"2026-02-21T17:32:43Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-8i5","depends_on_id":"aura-plugins-35d","type":"blocks","created_at":"2026-02-21T17:31:31Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-8i5","depends_on_id":"aura-plugins-7iy","type":"blocks","created_at":"2026-02-21T18:24:17Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-8i5","depends_on_id":"aura-plugins-exe","type":"blocks","created_at":"2026-02-21T17:32:43Z","created_by":"David Huu Pham","metadata":"{}"}],"comments":[{"id":12,"issue_id":"aura-plugins-8i5","author":"David Huu Pham","text":"SLICE-4 complete. All 47 new tests pass (207 total, 0 regressions). interfaces.py created with 4 runtime_checkable Protocol interfaces, A2A content types (TextPart, FilePart, DataPart, Part union, ToolCall), ModelId with parse() classmethod. Event stub types imported from types.py and re-exported. __init__.py updated to expose new public API.","created_at":"2026-02-22T01:47:00Z"},{"id":27,"issue_id":"aura-plugins-8i5","author":"David Huu Pham","text":"VOTE: ACCEPT (Reviewer B - Test Quality)\n\nSLICE-4 (interfaces.py): Tests import from production modules. Protocol interfaces are NOT mocked — tests instantiate concrete inline classes to verify structural subtyping. AC9 (isinstance without subclassing) verified for all 4 Protocol types. AC10 (ModelId.parse) covered with 11 test cases. A2A Part union types (TextPart/FilePart/DataPart), ToolCall, and event stub re-exports all tested for construction, immutability, and correct field values.\n\nSeverity groups: aura-plugins-j6h (BLOCKER, empty/closed), aura-plugins-5zf (IMPORTANT: no test verifies isinstance(RuntimeConstraintChecker(), ConstraintValidatorInterface) — the production implementor is not validated against its own interface), aura-plugins-4u1 (MINOR: test naming for ToolCall non-hashable, whitespace edge case for ModelId.parse).\nNo BLOCKERs. ACCEPT.","created_at":"2026-02-22T02:23:50Z"},{"id":31,"issue_id":"aura-plugins-8i5","author":"David Huu Pham","text":"VOTE: ACCEPT - SLICE-4 (interfaces.py) correctly implements AC9 and AC10. All 4 Protocol interfaces are @runtime_checkable; isinstance() returns True for structural implementors without inheritance (AC9 met); ModelId.parse() correctly validates provider/model format, raises ValueError for missing slash/empty parts, splits on first slash only (AC10 met); A2A Part union covers TextPart/FilePart/DataPart; event stubs are re-exported from types.py without duplication. Two non-blocking findings: (1) IMPORTANT: TYPE_CHECKING-only imports for EpochState/ConstraintViolation are correct Python practice but should be documented more explicitly for future implementors; (2) MINOR: FilePart.file_uri field name is a known v1 simplification from the A2A spec — migration path to full A2A compliance in v2 should be noted in docstring.","created_at":"2026-02-22T02:24:45Z"}]}
{"id":"aura-plugins-8jy","title":"SLICE-1-REVIEW-B-1 MINOR","description":"Reviewer B (Test Quality) — SLICE-1 (types.py / __init__.py) minor-level findings.\n\n## Finding: TestConstraintSpecs.test_known_constraints_present uses a fixed hardcoded subset — does not verify ALL 22 constraints (MINOR)\n\ntest_aura_types.py line 289-294 checks 8 specific constraint IDs are present. The schema-sync integration test (test_schema_types_sync.py) does verify ALL constraints against schema.xml, so this is covered at the integration level. However, the unit test could be replaced with a count check (assert len(CONSTRAINT_SPECS) == 22) to make the intent clearer. This is minor because the integration test provides full coverage.\n\n## Finding: _make_state helper in test_constraints.py uses **kwargs pass-through to EpochState constructor — obscures which fields are being set in individual tests (MINOR)\n\nThe _make_state(phase, epoch_id, **kwargs) helper delegates all extra kwargs directly to EpochState. While functional, this means a reader cannot see from the helper signature which fields are valid. Named helper variants (_make_state_at_p4_with_votes, _make_state_at_p10_with_votes, _all_accept_state) partially address this. Recommend adding typed overloads or named parameters for the most common cases (blocker_count, current_role). This improves fixture clarity but does not affect correctness.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:50Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:20:50Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-8pm","title":"SLICE-2-REVIEW-A-1 BLOCKER","description":"Reviewer A (Correctness) — SLICE-2 (state_machine.py) — BLOCKER findings.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:52Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:01Z","closed_at":"2026-02-22T02:22:01Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-919","title":"SLICE-2-REVIEW-B-1 BLOCKER","description":"Reviewer B (Test Quality) — SLICE-2 (state_machine.py) blocker-level findings.\n\n## Finding Summary\n\nNO BLOCKER findings identified for SLICE-2.\n\n- Tests import from production modules (aura_protocol.state_machine, aura_protocol.types).\n- SUT (EpochStateMachine) is NOT mocked. Tests exercise real state machine instances.\n- All 4 AC tests (AC1-AC4) present and test observable outcomes (exceptions raised, return values, state after advance).\n- DI via constructor injection (custom specs param) is tested and working.\n- Integration with full 12-phase lifecycle verified (_advance_to helper + TestSequentialProgression).\n- _CONSENSUS_GATED only includes P4→P5 (not P10→P11); P10→P11 consensus is gated by _BLOCKER_GATED and a separate advance-time check. Tests cover both paths correctly.\n\nThis group is empty and will be closed immediately.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:06Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:21:34Z","closed_at":"2026-02-22T02:21:34Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-947","title":"SLICE-3-REVIEW-C-1 IMPORTANT","description":"Reviewer C (Elegance) — SLICE-3 IMPORTANT severity group.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:38Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:20:38Z","labels":["aura:p10-impl:s10-review","aura:severity:important"],"dependencies":[{"issue_id":"aura-plugins-947","depends_on_id":"aura-plugins-in8","type":"blocks","created_at":"2026-02-21T18:21:41Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-99q","title":"URD: Release automation requirements document","description":"---\nreferences:\n  request: aura-plugins-j2k\n  elicit: aura-plugins-wqw\n---\n\n# URD: Automated Release Tagging and Version Bumping\n\n## 1. Purpose\nA CLI tool (bin/aura-release) that automates version bumping, CHANGELOG generation, git commit, and annotated tagging for the aura-plugins repository.\n\n## 2. Scope\n- Single Python 3.10+ script, stdlib only (zero external dependencies)\n- Follows existing bin/ tool conventions (argparse, same shebang pattern)\n- Operates on the local git repository only (no push)\n\n## 3. Functional Requirements\n\n### FR-1: Version Bump\n- Accept bump type: major | minor | patch\n- Parse current version from pyproject.toml (source of truth)\n- Compute new version per semver rules\n- Update version in exactly 3 files:\n  - pyproject.toml: project.version field\n  - .claude-plugin/plugin.json: top-level version field\n  - .claude-plugin/marketplace.json: metadata.version AND plugins[0].version\n- Must NOT modify plugins[1].version (agentfilter, external)\n\n### FR-2: Version Consistency Check\n- Before bumping, validate all 3 files have the same version\n- If versions are inconsistent, offer a --sync flag to align them to pyproject.toml's version before bumping\n- On first run with existing drift, --sync aligns marketplace.json to current 0.2.2\n\n### FR-3: CHANGELOG Generation\n- Auto-generate CHANGELOG.md entries from git log between tags\n- Use \"Keep a Changelog\" format (https://keepachangelog.com)\n- Group commits by type using conventional commit prefixes (feat, fix, chore, etc.)\n- If no prior tag exists, include all commits since initial commit\n\n### FR-4: Git Commit\n- Stage the 3 version files + CHANGELOG.md\n- Create commit with message: \"chore: release vX.Y.Z\"\n\n### FR-5: Git Tag\n- Create annotated tag: vX.Y.Z\n- Tag message: \"Release vX.Y.Z\"\n\n## 4. Non-Functional Requirements\n\n### NFR-1: Pre-flight Checks\n- Working tree must be clean (no uncommitted changes beyond .beads/)\n- Must be on a branch (not detached HEAD)\n- Current version must parse as valid semver\n\n### NFR-2: Dry Run\n- Support --dry-run flag showing what would happen without making changes\n\n### NFR-3: Error Handling\n- Atomic: if any step fails, roll back file changes (git checkout the files)\n- Clear error messages for each failure mode\n\n### NFR-4: Idempotency\n- Running with --sync when versions already match is a no-op\n\n## 5. CLI Interface\n\n```\naura-release \u003cmajor|minor|patch\u003e [--dry-run] [--sync] [--no-changelog] [--no-commit] [--no-tag]\naura-release --check  # just validate version consistency\n```\n\n## 6. Files Affected\n- bin/aura-release (NEW — the tool itself)\n- pyproject.toml (version field)\n- .claude-plugin/plugin.json (version field)\n- .claude-plugin/marketplace.json (2 version fields)\n- CHANGELOG.md (created/appended)","status":"open","priority":2,"issue_type":"task","assignee":"architect","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:10:46Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:10:46Z","labels":["aura:p2-user:s2_2-urd"],"dependencies":[{"issue_id":"aura-plugins-99q","depends_on_id":"aura-plugins-wux","type":"blocks","created_at":"2026-02-21T12:11:27Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-9ii","title":"SLICE-3-L3: Impl — RuntimeConstraintChecker logic","description":"---\nreferences:\n  slice: aura-plugins-mrm\n  impl_plan: aura-plugins-06g\n---\n## Scope\nImplement all constraint check methods in RuntimeConstraintChecker. Makes L2 tests pass.\n\n## Files Owned\n- scripts/aura_protocol/constraints.py (fill in implementations)\n\n## Acceptance Criteria\nGiven RuntimeConstraintChecker when checking violated state then returns ConstraintViolation list should never silently pass violations","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:42Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:05:52Z","closed_at":"2026-02-22T02:05:52Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-9ii","depends_on_id":"aura-plugins-w28","type":"blocks","created_at":"2026-02-21T17:32:42Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-9nc","title":"SLICE-1-IMPL: types.py + __init__.py — enums, specs, lookup dicts","description":"---\nreferences:\n  slice: aura-plugins-35d\n  impl_plan: aura-plugins-06g\n---\n## Scope\nCreate scripts/aura_protocol/types.py and __init__.py. Define all enums (PhaseId, Domain, RoleId, VoteType, SeverityLevel), frozen dataclasses (Transition, PhaseSpec, ConstraintSpec, HandoffSpec), canonical lookup dicts (PHASE_SPECS, CONSTRAINT_SPECS, HANDOFF_SPECS, PHASE_DOMAIN), and event stub types.\n\n## Files Owned\n- scripts/aura_protocol/__init__.py\n- scripts/aura_protocol/types.py\n\n## Acceptance Criteria\nGiven types.py when imported then all enums are str Enums, all specs are frozen should never have mutable spec dataclasses","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:36Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:42:53Z","closed_at":"2026-02-22T01:42:53Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"]}
{"id":"aura-plugins-amx","title":"SLICE-5-L2: Tests — test_workflow.py (AC6, AC7, Temporal sandbox)","description":"---\nreferences:\n  slice: aura-plugins-lkz\n  impl_plan: aura-plugins-06g\n---\n## Scope\nWrite test_workflow.py with Temporal sandbox tests covering AC6 (durability) and AC7 (search attributes). Tests use Temporal test environment.\n\n## Files Owned\n- tests/test_workflow.py\n\n## Acceptance Criteria\nGiven test_workflow.py when run in Temporal sandbox then workflow advances via signals, search attrs updated should never mock the workflow itself","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:46Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:17:11Z","closed_at":"2026-02-22T02:17:11Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-amx","depends_on_id":"aura-plugins-r1n","type":"blocks","created_at":"2026-02-21T17:32:46Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-b5m","title":"HANDOFF: Architect → Supervisor for REQUEST aura-plugins-bj1","description":"---\nreferences:\n  request: aura-plugins-bj1\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n---\nHandoff from architect to supervisor. See handoff document at\n.git/.aura/handoff/aura-plugins-bj1/architect-to-supervisor.md","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:17:50Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:17:50Z","labels":["aura:p7-plan:s7-handoff"]}
{"id":"aura-plugins-bch","title":"IMPL_PLAN: bin/aura-release implementation","description":"---\nreferences:\n  proposal: aura-plugins-1bm\n---\n\nSingle slice: implement bin/aura-release per PROPOSAL-2.\nOne file to create, no files to modify (version files modified by the tool at runtime, not at build time).","status":"open","priority":2,"issue_type":"epic","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:19:22Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:19:22Z","labels":["aura:p8-impl:s8-plan"],"dependencies":[{"issue_id":"aura-plugins-bch","depends_on_id":"aura-plugins-6yr","type":"blocks","created_at":"2026-02-21T12:31:09Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-bch","depends_on_id":"aura-plugins-e19","type":"blocks","created_at":"2026-02-21T12:19:31Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-bj1","title":"REQUEST: SessionEntry database design — A2A/MCP-compliant variant-rich transcript schema","description":"---\nreferences:\n  related_epoch: aura-plugins-220\n  variant_rich_paper: /home/minttea/dev/agent-data-leverage/unified-schema/llm/research/variant-rich-paper.pdf\n  agentfilter_project: /home/minttea/codebases/dayvidpham/agentfilter/\n---\n\n## Verbatim User Request\n\n### SessionEntry, session_entries\n\nThe next thing is: the database design and code interface design that can encapsulate all the various steps, constraints, and roles of our PROCESS is going to be tricky. These will inherently be dealing with many variant roles and phases, each with their own schema for their transcripts, entries, tool calls, etc. This problem has a few steps.\n\n1. Part of this is a literature research task: I put a reference paper that deals with how to deal with variant-rich software environments in @llm/research/variant-rich-paper. Find its references and related works, and determine what architectures or solutions the software engineering research community has developed to deal with this problem. We are in a variant-rich software environment because our ingestion pipeline must account for (MANY model harnesses which may have MANY configurations, plugins and also interface with MANY models).\n\n2. There is another research task: we need a standardized, stable, uniform interface that we can use to adapt the transcript entries into. This is essentially the purpose of the Agent Context Protocol (ACP), which has been officially merged into the Agent2Agent Protocol (A2A). These have also been officially donated to the Linux Foundation. These protocols integrate and extend the Model Context Protocol (MCP).\n   * ACP: (https://agentcommunicationprotocol.dev/introduction/welcome) and its official OpenAPI spec (https://raw.githubusercontent.com/i-am-bee/acp/refs/heads/main/docs/spec/openapi.yaml)\n   * A2A: official v1.0 spec (https://a2a-protocol.org/latest/definitions/) ; official A2A Go SDK (https://github.com/a2aproject/a2a-go) ; \n   * MCP: official spec at (https://modelcontextprotocol.io/specification/2025-11-25) and specified as TypeScript (https://raw.githubusercontent.com/modelcontextprotocol/modelcontextprotocol/refs/heads/main/schema/2025-11-25/schema.ts)\nWe should define a database schema and design that is compliant with the A2A and MCP schema. When researching, use these links provided as the official, single source of truth. I have an example of an ACP-compliant Claude Code transcript parser and filtering project at @~/codebases/dayvidpham/agentfilter/ .\n\n### Model Name ID Refactor\n\nLet's also use the database of models at https://github.com/anomalyco/models.dev, since we need a stable model name identifier.\n\n## Classification (4 Axes)\n\n### Scope: LARGE\n- Database schema design for variant-rich transcript storage\n- Protocol compliance with 3 specs (A2A v1.0, ACP, MCP 2025-11-25)\n- Literature survey on variant-rich SPL architectures\n- Model name ID standardization via models.dev\n- Integration with existing agentfilter project patterns\n\n### Complexity: HIGH\n- Multiple protocol specs to reconcile (A2A extends ACP extends MCP)\n- Variant-rich environment: MANY model harnesses × MANY configs × MANY models\n- Must handle variant transcripts per role/phase/tool with different schemas\n- Relevant SPL techniques: Feature Model Synthesis, Constraints Extraction, Variant Integration\n\n### Risk: MEDIUM\n- Research and design phase — not touching production yet\n- Risk of over-engineering the schema if we don't bound scope\n- Risk of protocol spec drift (A2A recently donated to Linux Foundation)\n\n### Domain Novelty: HIGH\n- A2A v1.0 spec released 2025 — cutting edge\n- SPL variant-rich evolution is active research area (Strüber et al. SPLC'19, 35 citations)\n- No existing unified transcript schema standard for multi-harness agent systems","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T23:50:40Z","created_by":"David Huu Pham","updated_at":"2026-02-21T23:50:40Z","labels":["aura:p1-user:s1_1-classify","aura:p1-user:s1_2-research","aura:p1-user:s1_3-explore"],"dependencies":[{"issue_id":"aura-plugins-bj1","depends_on_id":"aura-plugins-gbr","type":"blocks","created_at":"2026-02-21T16:38:37Z","created_by":"David Huu Pham","metadata":"{}"}],"comments":[{"id":2,"issue_id":"aura-plugins-bj1","author":"David Huu Pham","text":"## Phase 1 Research Synthesis (s1_2-research)\n\n### Stream A: Variant-Rich SPL Literature (Strüber et al. SPLC'19)\n\n**Top architectural patterns for our problem:**\n\n1. **Delta-Oriented Schema Composition** (Schaefer 2010, Schulze \u0026 Leymann 2014) — core schema + per-harness delta modules composed at build time. Directly applicable: `core.xml` + `delta-claude-code.xml` + `delta-opencode.xml`.\n\n2. **Annotative 150% Model with Feature Guards** (Kaestner et al. 2009) — single schema containing ALL elements with boolean feature guards. Current schema.xml already implicit 150% model; making guards explicit is the next step.\n\n3. **FAMILIAR Feature Model Merge/Synthesis** (Acher et al. 2013) — reverse-engineer unified feature model from N harness-specific schemas. The `merge`, `slice`, `aggregate` operators encode each variant as propositional formula.\n\n4. **VariantSync Session-Oriented Editing** (Bittner et al. ESEC/FSE 2022) — when modifying schema for one harness, system computes which other variants share those features and propagates automatically. 94.5% of edits fall into 2 classes (AddToPC, RemFromPC).\n\n5. **Data Migration Product Lines** (Romero-Organvidez et al. VaMoS 2024) — SPL techniques applied to ETL pipelines. Feature model of transformations composed per harness config. Closest analogue to our problem.\n\n**Recommended: Hybrid compositional-annotative architecture (3 layers)**\n- Layer 1: Core schema (mandatory features, all harnesses)\n- Layer 2: Delta modules (harness-specific additions)\n- Layer 3: Feature guards (cross-cutting concerns, SAT-verified)\n\n**Key tool: python-sat or z3-solver** for constraint validation of Given/When/Then rules.\n\n### Stream B: A2A/ACP/MCP Protocol Specs\n\n**Protocol composition (layered stack):**\n- Layer 1: MCP = agent-to-tool (intra-agent tool calls, resources, prompts)\n- Layer 2: ACP = bridge (sessions, trajectory observability, MIME-typed parts) — NOW MERGED INTO A2A\n- Layer 3: A2A = agent-to-agent (discovery, task delegation, streaming)\n\n**Adopt directly from A2A:**\n- `Part` discriminated union (TextPart/FilePart/DataPart with `kind` discriminator)\n- `TaskState` enum (superset of all 3 protocols)\n- `ContextID` pattern for session grouping (simpler than ACP Session)\n- `Metadata map[string]any` extensibility on every type\n\n**Adopt directly from MCP:**\n- `ToolUseContent` / `ToolResultContent` for tool call representation\n- `Tool.annotations` (readOnlyHint, destructiveHint, idempotentHint)\n\n**Extend:**\n- Add `tool_use`/`tool_result` Part kinds (MCP's model, not in A2A)\n- Add `reasoning` field (from ACP TrajectoryMetadata.message)\n- Add `source` field (harness, model, protocol) — none of the 3 have this\n- Extend MessageRole to \"user\"|\"assistant\"|\"tool\"|\"system\"\n\n**Ignore:** AgentCard discovery, push notifications, ACP Session model, MCP Resource/Prompt registration, MCP Elicitation\n\n### Stream C: Existing Codebase Patterns\n\n**agentfilter reusable patterns:**\n- Three-way decision model (allow/deny/pass) → transcript classification\n- Specificity-based precedence resolution (8-level IntEnum)\n- Universal tool call envelope: `(session_id, tool_call_id, tool_name, tool_input)`\n- Operation classification: READ/WRITE/UNKNOWN frozensets\n- Dual-track parsing: heuristic fast-path + AST slow-path\n\n**models.dev integration:**\n- Composite identifier: `{provider_id}/{model_id}` (e.g., `anthropic/claude-opus-4-6`)\n- ModelFamily enum (~150 values): `claude-opus`, `gpt`, `gemini-flash`, etc.\n- Zod-validated schema with capabilities, cost, limits\n- API at `https://models.dev/api.json` — cache locally for offline resolution\n- Store: model_provider, model_id, model_family, model_name + capability snapshot","created_at":"2026-02-21T23:57:04Z"},{"id":3,"issue_id":"aura-plugins-bj1","author":"David Huu Pham","text":"## Proposed Canonical TranscriptEntry Schema (from research)\n\n```\nTranscriptEntry {\n  id:           UUID\n  timestamp:    ISO 8601\n  session_id:   UUID          // A2A ContextID\n  task_id:      UUID?         // A2A TaskID / ACP RunId\n  role:         \"user\"|\"assistant\"|\"tool\"|\"system\"\n  content:      ContentPart[]\n  tool_use?: {\n    id:         string\n    name:       string        // MCP tool name\n    input:      object\n  }\n  tool_result?: {\n    tool_use_id: string\n    content:     ContentPart[]\n    is_error:    bool\n  }\n  reasoning?:   string        // ACP TrajectoryMetadata.message\n  references:   UUID[]        // A2A referenceTaskIds\n  metadata:     map[string, any]\n  source: {\n    harness:    string        // \"claude-code\", \"opencode\", etc.\n    model:      string?       // models.dev canonical ID\n    protocol:   \"mcp\"|\"a2a\"|\"raw\"\n  }\n}\n\nContentPart (discriminated union via \"type\"):\n  { type:\"text\", text, mime_type? }\n  { type:\"file\", data? (base64), uri?, mime_type, filename? }\n  { type:\"data\", data: object, mime_type? }\n  { type:\"resource_link\", uri, name?, mime_type? }\n```\n\nPhase 1 research complete. Ready for Phase 2 (URE/URD).","created_at":"2026-02-21T23:57:12Z"}]}
{"id":"aura-plugins-bnr","title":"SLICE-3-REVIEW-A-1 IMPORTANT","description":"Reviewer A (Correctness) — SLICE-3 (constraints.py) — IMPORTANT findings.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:22:53Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:53Z","labels":["aura:p10-impl:s10-review","aura:severity:important"],"dependencies":[{"issue_id":"aura-plugins-bnr","depends_on_id":"aura-plugins-jwb","type":"blocks","created_at":"2026-02-21T18:23:24Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-btb","title":"SLICE-1-REVIEW-C-1: types.py — Protocol type definitions","description":"VOTE: ACCEPT\n\n## Review Summary (Reviewer C — Elegance and Complexity Proportionality)\n\nSLICE-1 (types.py + __init__.py) is exemplary in elegance proportionality.\n\n### Strengths\n- The 5-enum set (PhaseId, Domain, RoleId, VoteType, SeverityLevel) maps 1:1 to the 5 distinct conceptual axes in schema.xml. No enum proliferation.\n- str Enum choice is correct: JSON serialization AND Temporal serialization both work natively without custom encoding.\n- frozen=True dataclasses for all spec types is the right choice: immutable protocol definitions that can be safely shared and used as dict keys. No over-engineering via Pydantic; no under-engineering by using plain tuples.\n- PHASE_SPECS, CONSTRAINT_SPECS, HANDOFF_SPECS as module-level dicts are a clean static definition pattern. No runtime construction, no registry, no factory — just data.\n- The event stub types (PhaseTransitionEvent, ConstraintCheckEvent, etc.) bridge the interface gap without adding Pydantic or a separate event bus dependency.\n- __init__.py re-exports are complete and the __all__ list matches. Public API surface is exactly what is needed.\n- PHASE_DOMAIN using frozenset keys is elegant: the COMPLETE sentinel is correctly excluded.\n\n### Minor Finding\n- aura-plugins-n0n: AuditEvent.payload typed as str (JSON-serialized) — minor inconsistency with the typed dataclass pattern used elsewhere.\n\n### Verdict\nNo BLOCKER or IMPORTANT findings. One MINOR. SLICE-1 ACCEPT.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:23:20Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:23:20Z","labels":["aura:p10-impl:s10-review"]}
{"id":"aura-plugins-d7j","title":"SLICE-1-REVIEW-A-1 BLOCKER","description":"Reviewer A (Correctness) — SLICE-1 (types.py, __init__.py) — BLOCKER findings. No blockers found.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:06Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:21:20Z","closed_at":"2026-02-22T02:21:20Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-don","title":"SLICE-2-REVIEW-C-1 IMPORTANT","description":"Reviewer C (Elegance) — SLICE-2 IMPORTANT severity group.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:36Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:20:36Z","labels":["aura:p10-impl:s10-review","aura:severity:important"],"dependencies":[{"issue_id":"aura-plugins-don","depends_on_id":"aura-plugins-r8m","type":"blocks","created_at":"2026-02-21T18:21:25Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-dvi","title":"SLICE-3-REVIEW-A-1 MINOR","description":"Reviewer A (Correctness) — SLICE-3 (constraints.py) — MINOR findings.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:22:53Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:53Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"],"dependencies":[{"issue_id":"aura-plugins-dvi","depends_on_id":"aura-plugins-qqf","type":"blocks","created_at":"2026-02-21T18:23:39Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-dwy","title":"PROPOSAL-1-REVIEW-B-1: aura protocol engine v1","description":"VOTE: ACCEPT - The test strategy is well-designed with strong integration test foundations, proper fixture reuse, and observable-outcome assertions. Minor observations below do not rise to BLOCKER level.\n\n## Axis B: Test Quality Assessment\n\n### 1. Test File Plan Sufficiency\n\nThe 6 test files are well-scoped and properly partitioned:\n\n- **test_aura_types.py** — Enum coverage and spec completeness. This is appropriate: verifying that all PhaseId, Domain, RoleId, VoteType, SeverityLevel values exist and are correctly typed is a foundation test, not a brittle unit test. It tests observable contract (enum membership), not internal state.\n\n- **test_state_machine.py** — Transition validation and review gates. This is the most important test file. The BDD acceptance criteria (AC1-AC4) map directly to observable outcomes: calling advance() either succeeds and records a TransitionRecord, or raises TransitionError with specific violation messages. The SUT (EpochStateMachine) is tested directly — no mocking of the state machine itself.\n\n- **test_constraints.py** — Runtime constraint checking. Tests assert that check_all() and check_transition() return ConstraintViolation lists with constraint_ids and messages. Observable output, not internal state.\n\n- **test_workflow.py** — Temporal workflow sandbox tests. Temporal provides a dedicated test environment (WorkflowEnvironment.start_local()) that runs a real Temporal server in-memory. The SUT is the actual EpochWorkflow — only the Temporal infrastructure is provided by the test harness. This is a proper integration test pattern.\n\n- **test_interfaces.py** — Protocol compliance verification via isinstance() checks on runtime_checkable Protocols. This verifies structural subtyping contracts — exactly what end-users of the interfaces need.\n\n- **test_schema_types_sync.py** — THE critical integration test. Verifies that Python type definitions match schema.xml. This is the gold standard: the SUT is the types.py module, the dependency is schema.xml (parsed fresh), and the assertion is completeness (every schema.xml entity has a corresponding Python type).\n\n**Verdict: SUFFICIENT.** The file plan covers all modules and the most important invariants.\n\n### 2. Integration Test Strategy\n\n**test_schema_types_sync.py** is the linchpin integration test:\n- It verifies Python types match schema.xml entities (PhaseId, Domain, RoleId, VoteType, SeverityLevel)\n- It verifies PHASE_DOMAIN mapping matches _EXPECTED_DOMAINS from validate_schema.py\n- It verifies the transition table covers all schema.xml \u003ctransitions\u003e\n- It ensures the two representations (XML and Python code) cannot drift apart\n\nThis directly extends the existing SchemaFixture mutation testing pattern established in validate_schema.py, which is good continuity. The proposal explicitly states this in the validation checklist (items 1-5 and 17).\n\nThe existing test infrastructure (SchemaFixture, SchemaMutation, parametrized mutation detection) demonstrates the codebase already follows integration-first testing. The proposal correctly extends this pattern.\n\n**Verdict: STRONG integration strategy.**\n\n### 3. BDD Acceptance Criteria Testability\n\nAll 10 acceptance criteria (AC1-AC10) follow Given/When/Then/Should Not format and are testable:\n\n- **AC1 (transitions):** Given/When/Then maps to: create state machine, call advance(), assert TransitionRecord returned, assert error on invalid skip.\n- **AC2 (consensus gate):** Given/When/Then maps to: record 2 of 3 votes, call advance(p5), assert TransitionError.\n- **AC3 (revision loop):** Given/When/Then maps to: record REVISE vote, check available_transitions, assert only p3.\n- **AC4 (BLOCKER gate):** Given/When/Then maps to: set blocker_count \u003e 0, call advance(p11), assert TransitionError.\n- **AC5 (constraint enforcement):** Given/When/Then maps to: create checker, pass violated state, assert ConstraintViolation list.\n- **AC6 (Temporal durability):** Given/When/Then maps to: start workflow in sandbox, send signal, assert state and search attributes updated.\n- **AC7 (forensic query):** Given/When/Then maps to: start workflow at p9, query by search attribute, assert workflow found.\n- **AC8 (schema-types sync):** Given/When/Then maps to: parse schema.xml, compare to Python types, assert complete coverage.\n- **AC9 (interface compliance):** Given/When/Then maps to: create conforming class, assert isinstance() returns True.\n- **AC10 (ModelId parsing):** Given/When/Then maps to: parse valid string, assert fields, assert ValueError on invalid.\n\n**Verdict: ALL criteria are testable and complete.** Each maps to a specific test with observable output (return values, exceptions, or isinstance results). None require inspecting private state.\n\n### 4. Temporal Workflow Testability\n\nThe proposal correctly identifies that Temporal provides a sandbox test environment. The Temporal Python SDK offers:\n- `WorkflowEnvironment.start_local()` for a local in-memory Temporal server\n- Signal/query APIs for driving the workflow from tests\n- Search attribute queries for verifying forensic capabilities\n\nThe key design decision here is sound: the workflow wraps EpochStateMachine (tested separately in test_state_machine.py) and exposes signals/queries. The Temporal test would:\n1. Start the workflow in sandbox\n2. Send PhaseAdvanceSignal\n3. Query current_state() and assert phase changed\n4. Verify search attributes via the Temporal client\n\nThis is an integration test by nature — the real workflow code runs in a real (local) Temporal environment. The SUT (EpochWorkflow) is not mocked. Dependencies (Temporal server) are provided by the test harness.\n\n**Verdict: PROPERLY testable.** Temporal's sandbox testing is the right approach.\n\n### 5. Leverage of Existing Mutation Testing Framework\n\nThe proposal references SchemaFixture in test_schema_types_sync.py's integration test strategy. The existing framework provides:\n- `SchemaFixture` class for loading and mutating schema.xml\n- `SchemaMutation` dataclass for defining specific mutations\n- Parametrized testing for combinatorial coverage\n\nThe proposal's test_schema_types_sync.py would complement this: while SchemaFixture tests that validate_schema.py catches broken schemas, test_schema_types_sync.py tests that the Python type definitions match the valid schema. These are two sides of the same coin.\n\nThe proposal could potentially use SchemaFixture's `fresh_root()` to parse schema.xml in the integration tests, maintaining fixture reuse. This is not explicitly stated but is a natural extension.\n\n**Verdict: GOOD continuity with existing patterns.** The proposal extends rather than duplicates the mutation testing framework.\n\n### End-User Alignment Assessment\n\n1. **Who are the end-users?** Agent developers and protocol maintainers who need the state machine to enforce correct phase transitions.\n2. **What would end-users want?** Confidence that the protocol engine faithfully implements schema.xml rules — the test strategy delivers this via integration tests.\n3. **How would this affect them?** Drift between schema.xml and Python types would silently break protocol enforcement. test_schema_types_sync.py prevents this.\n4. **Are there implementation gaps?** Minor: the proposal does not specify whether test_workflow.py will use shared fixtures for EpochState construction across test files. Recommend a shared factory in tests/fixtures/.\n5. **Does MVP scope make sense?** Yes — the test files cover exactly the 5 modules proposed, plus the critical cross-module integration test.\n6. **Is validation checklist complete?** Yes — 17 items covering all testable properties.\n\n### Minor Observations (Non-Blocking)\n\n1. **Shared fixtures:** The proposal would benefit from an explicit shared fixture plan (e.g., a `tests/fixtures/epoch_fixtures.py` with factory functions for EpochState, PhaseSpec, ConstraintSpec). The existing SchemaFixture pattern shows the codebase values this. Not a blocker because the implementation phase will naturally create these.\n\n2. **Negative test cases for workflow:** AC6 says \"should not allow non-deterministic operations\" but this is hard to test directly (Temporal enforces this via sandbox replay). The AC phrasing is aspirational rather than testable — but the positive case (deterministic signal-driven transitions) is sufficient for v1.\n\n3. **test_constraints.py coverage:** The proposal lists 4 specific constraint checkers (check_review_consensus, check_dep_direction, check_severity_tree, check_handoff_required) but the validation checklist item 9 says \"Constraint checker catches all C-* constraints from schema.xml.\" The test should parametrize over all C-* constraint IDs from schema.xml to ensure completeness. This is an implementation detail best left to the worker, not a plan-level concern.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:00:38Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:00:38Z","labels":["aura:p4-plan:s4-review"]}
{"id":"aura-plugins-e0j","title":"CODE-REVIEW-ROUND-1: aura_protocol engine v1 MVP","description":"---\nreferences:\n  request: aura-plugins-bj1\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n  impl_plan: aura-plugins-06g\n---\n## Code Review Round 1\n\n### Slices Under Review\n- SLICE-1 (aura-plugins-35d): types.py — Protocol type definitions\n- SLICE-2 (aura-plugins-la6): state_machine.py — 12-phase epoch lifecycle\n- SLICE-3 (aura-plugins-mrm): constraints.py — Runtime constraint validators\n- SLICE-4 (aura-plugins-8i5): interfaces.py — Cross-project integration + A2A types\n- SLICE-5 (aura-plugins-lkz): workflow.py — Temporal workflow wrapper\n\n### Reviewers\n- Reviewer A (Correctness): Spirit and technical accuracy\n- Reviewer B (Test quality): Test coverage, DI, integration focus\n- Reviewer C (Elegance): Complexity proportionality, API design\n\n### Files to Review\n- scripts/aura_protocol/__init__.py\n- scripts/aura_protocol/types.py\n- scripts/aura_protocol/state_machine.py\n- scripts/aura_protocol/constraints.py\n- scripts/aura_protocol/interfaces.py\n- scripts/aura_protocol/workflow.py\n- tests/test_aura_types.py\n- tests/test_schema_types_sync.py\n- tests/test_state_machine.py\n- tests/test_constraints.py\n- tests/test_interfaces.py\n- tests/test_workflow.py\n- pyproject.toml (modified)\n\n### Test Results\n458 tests passing, 0 failures, 0 regressions","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:18:30Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:18:30Z","labels":["aura:p10-impl:s10-review"],"dependencies":[{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-0ac","type":"blocks","created_at":"2026-02-21T18:20:55Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-0yd","type":"blocks","created_at":"2026-02-21T18:22:07Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-1eo","type":"blocks","created_at":"2026-02-21T18:24:55Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-1ic","type":"blocks","created_at":"2026-02-21T18:21:57Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-1ka","type":"blocks","created_at":"2026-02-21T18:20:55Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-1wg","type":"blocks","created_at":"2026-02-21T18:23:57Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-20c","type":"blocks","created_at":"2026-02-21T18:20:52Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-295","type":"blocks","created_at":"2026-02-21T18:20:54Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-3xe","type":"blocks","created_at":"2026-02-21T18:24:55Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-4u1","type":"blocks","created_at":"2026-02-21T18:22:39Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-5s5","type":"blocks","created_at":"2026-02-21T18:22:57Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-5zf","type":"blocks","created_at":"2026-02-21T18:22:39Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-68o","type":"blocks","created_at":"2026-02-21T18:23:16Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-7d2","type":"blocks","created_at":"2026-02-21T18:23:58Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-7no","type":"blocks","created_at":"2026-02-21T18:20:52Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-80v","type":"blocks","created_at":"2026-02-21T18:21:15Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-8be","type":"blocks","created_at":"2026-02-21T18:20:54Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-8jy","type":"blocks","created_at":"2026-02-21T18:20:54Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-8pm","type":"blocks","created_at":"2026-02-21T18:21:56Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-919","type":"blocks","created_at":"2026-02-21T18:21:32Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-947","type":"blocks","created_at":"2026-02-21T18:20:53Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-bnr","type":"blocks","created_at":"2026-02-21T18:22:57Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-d7j","type":"blocks","created_at":"2026-02-21T18:21:15Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-don","type":"blocks","created_at":"2026-02-21T18:20:52Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-dvi","type":"blocks","created_at":"2026-02-21T18:22:58Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-gdx","type":"blocks","created_at":"2026-02-21T18:20:56Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-h21","type":"blocks","created_at":"2026-02-21T18:21:15Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-h7x","type":"blocks","created_at":"2026-02-21T18:20:31Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-j6h","type":"blocks","created_at":"2026-02-21T18:22:39Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-m5o","type":"blocks","created_at":"2026-02-21T18:20:31Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-ngd","type":"blocks","created_at":"2026-02-21T18:23:57Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-nq6","type":"blocks","created_at":"2026-02-21T18:20:31Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-nsl","type":"blocks","created_at":"2026-02-21T18:22:07Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-o83","type":"blocks","created_at":"2026-02-21T18:21:33Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-pbc","type":"blocks","created_at":"2026-02-21T18:23:16Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-pxo","type":"blocks","created_at":"2026-02-21T18:20:54Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-sgf","type":"blocks","created_at":"2026-02-21T18:20:53Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-sk6","type":"blocks","created_at":"2026-02-21T18:23:17Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-tcn","type":"blocks","created_at":"2026-02-21T18:21:56Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-utj","type":"blocks","created_at":"2026-02-21T18:20:55Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-v1b","type":"blocks","created_at":"2026-02-21T18:21:33Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-x36","type":"blocks","created_at":"2026-02-21T18:20:56Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-xui","type":"blocks","created_at":"2026-02-21T18:24:56Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-ye3","type":"blocks","created_at":"2026-02-21T18:20:53Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-e0j","depends_on_id":"aura-plugins-yno","type":"blocks","created_at":"2026-02-21T18:22:07Z","created_by":"David Huu Pham","metadata":"{}"}],"comments":[{"id":29,"issue_id":"aura-plugins-e0j","author":"David Huu Pham","text":"Reviewer B (Test Quality) — CODE-REVIEW-ROUND-1 Summary\n\n## Overall Vote: ACCEPT (all 5 slices)\n\nAll 5 slices accepted. No BLOCKER findings across any slice. 458 tests pass.\n\n## Severity Group Summary\n\n| Slice | BLOCKER | IMPORTANT | MINOR |\n|-------|---------|-----------|-------|\n| SLICE-1 (types.py) | aura-plugins-ye3 (empty, closed) | aura-plugins-295 | aura-plugins-8jy |\n| SLICE-2 (state_machine.py) | aura-plugins-919 (empty, closed) | aura-plugins-o83 | aura-plugins-v1b |\n| SLICE-3 (constraints.py) | aura-plugins-nsl (empty, closed) | aura-plugins-yno | aura-plugins-0yd |\n| SLICE-4 (interfaces.py) | aura-plugins-j6h (empty, closed) | aura-plugins-5zf | aura-plugins-4u1 |\n| SLICE-5 (workflow.py) | aura-plugins-pbc (empty, closed) | aura-plugins-68o | aura-plugins-sk6 |\n\n## Top IMPORTANT Findings (for follow-up epic)\n\n1. **SLICE-3**: check_all() only aggregates 5 of 22 C-* constraints — the completeness contract is undocumented (aura-plugins-yno)\n2. **SLICE-2**: P10→P11 consensus enforcement is split between state_machine (_BLOCKER_GATED only) and constraint layer (check_review_consensus) — inconsistent enforcement boundary (aura-plugins-o83)\n3. **SLICE-4**: No test verifies isinstance(RuntimeConstraintChecker(), ConstraintValidatorInterface) — production implementor not tested against its own Protocol (aura-plugins-5zf)\n4. **SLICE-5**: No full WorkflowEnvironment sandbox test — Temporal signal wire-up is untested end-to-end (aura-plugins-68o)\n\n## Test Quality Assessment\n\nStrengths:\n- All imports are from production modules — no inline implementation mocks\n- SUT is never mocked in any test file — only dependencies are mocked/injected\n- Tests verify observable outcomes exclusively: return values, exceptions, field values\n- DI via constructor injection throughout (EpochStateMachine(specs=...), RuntimeConstraintChecker(constraint_specs=...))\n- test_schema_types_sync.py is a strong integration test preventing schema.xml drift\n- ActivityEnvironment usage for Temporal activity tests is the correct approach\n- AC1–AC10 all have test coverage\n\nConcerns (follow-up items):\n- _advance_to helper duplicated between test_state_machine.py and test_workflow.py (MINOR, SLICE-2 + SLICE-5)\n- Exception type specificity in freeze tests uses bare Exception instead of FrozenInstanceError (MINOR, SLICE-1)\n- Missing: conftest.py with shared fixtures (epoch factory, transition record factory)","created_at":"2026-02-22T02:24:13Z"},{"id":30,"issue_id":"aura-plugins-e0j","author":"David Huu Pham","text":"Reviewer B (Test Quality): ACCEPT all 5 slices. 0 BLOCKERs, 4 IMPORTANT findings (check_all coverage, P10 consensus split, Protocol self-check, missing WorkflowEnvironment test). 15 severity groups created.","created_at":"2026-02-22T02:24:39Z"},{"id":32,"issue_id":"aura-plugins-e0j","author":"David Huu Pham","text":"VOTE: ACCEPT — Reviewer C (Elegance and Complexity Proportionality)\n\n## Overall Assessment\n\nAll 5 slices ACCEPT. No BLOCKER findings across any slice. 3 IMPORTANT findings and 3 MINOR findings documented for follow-up.\n\n## Per-Slice Verdicts\n\n| Slice | Task | Vote | Severity Groups |\n|-------|------|------|-----------------|\n| SLICE-1 (types.py) | aura-plugins-btb | ACCEPT | 0 BLOCKER, 0 IMPORTANT, 1 MINOR |\n| SLICE-2 (state_machine.py) | aura-plugins-0gt | ACCEPT | 0 BLOCKER, 1 IMPORTANT, 0 MINOR |\n| SLICE-3 (constraints.py) | aura-plugins-mki | ACCEPT | 0 BLOCKER, 1 IMPORTANT, 1 MINOR |\n| SLICE-4 (interfaces.py) | aura-plugins-7iy | ACCEPT | 0 BLOCKER, 0 IMPORTANT, 1 MINOR |\n| SLICE-5 (workflow.py) | aura-plugins-z3n | ACCEPT | 0 BLOCKER, 1 IMPORTANT, 1 MINOR |\n\n## IMPORTANT Findings (follow-up required)\n\n1. aura-plugins-r8m (SLICE-2): EpochState.current_role is typed str instead of RoleId, breaking the strongly-typed enum invariant. Every other protocol entity uses the typed enum; this one field uses a bare string, making it invisible to type checkers and inconsistent with the design philosophy.\n\n2. aura-plugins-in8 (SLICE-3): check_severity_tree() only enforces the NEGATIVE case of C-severity-eager (p4 must NOT have severity trees) but not the POSITIVE case (p10 MUST have them eagerly). The method name implies full coverage of C-severity-eager. This is a misleading API surface that creates a false confidence gap.\n\n3. aura-plugins-i2g (SLICE-5): Bare except Exception in EpochWorkflow.run() silently discards TransitionError. Callers who send an invalid advance_phase signal receive no feedback — the workflow stays at the current phase with no indication of why. Failed transitions are also not recorded in the audit trail, violating the forensic auditability goal of the URD.\n\n## MINOR Findings (optional cleanup)\n\n1. aura-plugins-n0n (SLICE-1): AuditEvent.payload typed as str (JSON-serialized) — inconsistent with the typed frozen dataclass pattern used for all other event stubs.\n2. aura-plugins-lkk (SLICE-3): _SAME_ACTOR frozenset defined as a local inside check_handoff_required() — inconsistent with all other module-level constants, recreated on every call.\n3. aura-plugins-eqy (SLICE-4): DataPart.data and ToolCall.tool_input/tool_output typed as bare dict — should be dict[str, Any] for type precision.\n4. aura-plugins-3m4 (SLICE-5): Post-hoc mutation of the last TransitionRecord in transition_history to apply a deterministic timestamp. Technically legal but unexpected and subtle; cleaner alternative is to pass timestamp into advance().\n\n## Design Quality Summary\n\nThe 5-module decomposition is proportionate to the 5 orthogonal problem axes (types, lifecycle, constraints, integration, durability). No premature abstractions were introduced. The str Enum + frozen dataclass pattern is applied consistently. The hand-rolled state machine over a library dependency is the right call for a fixed 12-phase topology. typing.Protocol for cross-repo integration is exactly the right tool. The Temporal boundary (signals for mutations, activities for I/O, queries for reads) is drawn correctly throughout.\n\nThe IMPORTANT findings are structural improvements that do not block correctness in v1 but should be addressed in a follow-up to prevent technical debt accumulation.","created_at":"2026-02-22T02:25:01Z"},{"id":33,"issue_id":"aura-plugins-e0j","author":"David Huu Pham","text":"Reviewer C (Elegance): ACCEPT all 5 slices. 0 BLOCKERs, 3 IMPORTANT (EpochState.current_role str vs RoleId, check_severity_tree incomplete positive case, bare except in workflow.run), 4 MINOR.","created_at":"2026-02-22T02:25:26Z"},{"id":35,"issue_id":"aura-plugins-e0j","author":"David Huu Pham","text":"VOTE: ACCEPT — Reviewer A (Correctness)\n\n## Overall Assessment\n\nAll 5 slices ACCEPT. 0 BLOCKER findings across all slices. 458 tests pass.\n\n## Per-Slice Verdicts\n\n| Slice | Task | Vote | Severity Groups |\n|-------|------|------|-----------------|\n| SLICE-1 (types.py) | aura-plugins-35d | ACCEPT | 0 BLOCKER (d7j closed), 0 IMPORTANT (80v closed), 0 MINOR (h21 closed) |\n| SLICE-2 (state_machine.py) | aura-plugins-la6 | ACCEPT | 0 BLOCKER (8pm closed), 1 IMPORTANT (tcn/ipj), 1 MINOR (1ic/4hu) |\n| SLICE-3 (constraints.py) | aura-plugins-mrm | ACCEPT | 0 BLOCKER (5s5 closed), 1 IMPORTANT (bnr/jwb), 1 MINOR (dvi/qqf) |\n| SLICE-4 (interfaces.py) | aura-plugins-8i5 | ACCEPT | 0 BLOCKER (1wg closed), 1 IMPORTANT (ngd/zpu), 1 MINOR (7d2/hls) |\n| SLICE-5 (workflow.py) | aura-plugins-lkz | ACCEPT | 0 BLOCKER (1eo closed), 1 IMPORTANT (3xe/6wg), 1 MINOR (xui/r8f) |\n\n## BDD Acceptance Criteria Verification (AC1-AC10)\n\n- AC1 (state transitions): PASS — p1→p2 succeeds, p1→p8 raises TransitionError, transition history recorded\n- AC2 (consensus gate): PASS — p4→p5 with 2/3 ACCEPT raises TransitionError('consensus')\n- AC3 (revision loop): PASS — any REVISE vote at p4/p10 limits available_transitions to backward-only\n- AC4 (BLOCKER gate): PASS — p10→p11 with blocker_count \u003e 0 raises TransitionError\n- AC5 (constraint enforcement): PASS — RuntimeConstraintChecker returns ConstraintViolation list with constraint_id and message\n- AC6 (Temporal durability): PASS — signal-driven, workflow.now() for timestamps, activities for I/O, no datetime.now() in workflow code\n- AC7 (forensic search attrs): PASS — SA_PHASE/ROLE/DOMAIN/STATUS/EPOCH_ID upserted on every transition\n- AC8 (schema-types sync): PASS — test_schema_types_sync.py parses schema.xml and validates all enum values and transition counts\n- AC9 (Protocol isinstance): PASS — all 4 Protocol interfaces are @runtime_checkable, isinstance() works without inheritance\n- AC10 (ModelId parsing): PASS — parse() validates format, raises ValueError for missing slash, splits on first slash only\n\n## IMPORTANT Findings (follow-up epic)\n\n1. aura-plugins-ipj (SLICE-2): advance() creates TransitionRecord with datetime.now() which is then post-hoc replaced by workflow layer via direct list mutation — cleaner to pass timestamp as explicit parameter to advance()\n2. aura-plugins-jwb (SLICE-3): check_severity_tree() enforces negative case (p4 must NOT have severity trees) but not positive case (p10 MUST have 3 groups eagerly) — EpochState needs severity_groups field to enable runtime enforcement\n3. aura-plugins-zpu (SLICE-4): TYPE_CHECKING-only imports for EpochState/ConstraintViolation are correct Python practice but the limitation (runtime isinstance() checks only method name, not signature) should be explicitly documented\n4. aura-plugins-6wg (SLICE-5): bare except Exception: swallows all exceptions including unexpected ones — should be except TransitionError: to allow real bugs to surface\n\n## MINOR Findings (follow-up epic)\n\n1. aura-plugins-4hu (SLICE-2): EpochState.current_role typed as str instead of RoleId — diverges from proposal spec, loses type safety\n2. aura-plugins-qqf (SLICE-3): check_blocker_gate() uses constraint_id 'C-worker-gates' for the blocker resolution gate — conflates two distinct enforcement concerns\n3. aura-plugins-hls (SLICE-4): FilePart.file_uri field name is a known v1 simplification from A2A spec — migration path to full A2A compliance should be noted in docstring\n4. aura-plugins-r8f (SLICE-5): SA_EPOCH_ID omitted from per-transition upsert_search_attributes — intentionally set-once but should be documented or made defensive","created_at":"2026-02-22T02:26:18Z"},{"id":36,"issue_id":"aura-plugins-e0j","author":"David Huu Pham","text":"Reviewer A (Correctness): ACCEPT all 5 slices. 0 BLOCKERs, 4 IMPORTANT (timestamp coupling, severity-eager incomplete, TYPE_CHECKING Protocol doc, bare except), 4 MINOR.","created_at":"2026-02-22T02:26:53Z"},{"id":37,"issue_id":"aura-plugins-e0j","author":"David Huu Pham","text":"CODE REVIEW ROUND 1 COMPLETE: 3/3 ACCEPT, 0 BLOCKERs. Consensus achieved. Creating EPIC_FOLLOWUP for IMPORTANT/MINOR findings.","created_at":"2026-02-22T02:26:53Z"}]}
{"id":"aura-plugins-e19","title":"SLICE-1: Implement bin/aura-release","description":"---\nreferences:\n  impl_plan: aura-plugins-bch\n  proposal: aura-plugins-1bm\n---\n\nImplement bin/aura-release per PROPOSAL-2.\nSingle file: bin/aura-release","status":"open","priority":2,"issue_type":"task","assignee":"worker","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:19:28Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:19:28Z","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-e19","depends_on_id":"aura-plugins-jjo","type":"blocks","created_at":"2026-02-21T12:23:45Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-eel","title":"SLICE-3-L1: Types — ConstraintViolation, RuntimeConstraintChecker skeleton","description":"---\nreferences:\n  slice: aura-plugins-mrm\n  impl_plan: aura-plugins-06g\n---\n## Scope\nDefine ConstraintViolation (frozen dataclass) and RuntimeConstraintChecker class skeleton with method signatures.\n\n## Files Owned\n- scripts/aura_protocol/constraints.py (type defs + method stubs)\n\n## Acceptance Criteria\nGiven constraints.py when imported then ConstraintViolation and RuntimeConstraintChecker importable should never have implementations yet","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:40Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:05:51Z","closed_at":"2026-02-22T02:05:51Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"]}
{"id":"aura-plugins-eqy","title":"SLICE-4-REVIEW-C-1-F1: DataPart.data and ToolCall dict fields unparameterized — should be dict[str, Any]","description":"## Finding\n\nIn interfaces.py, three dict fields are unparameterized:\n\n    @dataclass(frozen=True)\n    class DataPart:\n        data: dict   # should be dict[str, Any]\n\n    @dataclass(frozen=True)\n    class ToolCall:\n        tool_input: dict   # should be dict[str, Any]\n        tool_output: dict | None = None   # should be dict[str, Any] | None\n\nUsing bare dict (without type parameters) is less precise than dict[str, Any] and loses information for type checkers. PEP 585 (Python 3.9+) and the existing use of from __future__ import annotations means dict[str, Any] is available without runtime overhead.\n\n## Context\nThe rest of the codebase consistently parameterizes dicts: dict[str, ConstraintSpec], dict[PhaseId, PhaseSpec], dict[str, str] (context field on ConstraintViolation), etc. The unparameterized dict is the exception, not the rule.\n\n## Fix\n    from typing import Any\n    data: dict[str, Any]\n    tool_input: dict[str, Any]\n    tool_output: dict[str, Any] | None = None\n\nNote: dict[str, Any] is not actually more restrictive than Any — it still allows nested Any values. But it communicates the intent (string keys) and satisfies type checkers.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:22:34Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:34Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-exe","title":"SLICE-4-L2: Tests — test_interfaces.py (AC9, AC10)","description":"---\nreferences:\n  slice: aura-plugins-8i5\n  impl_plan: aura-plugins-06g\n---\n## Scope\nWrite test_interfaces.py testing AC9 (Protocol isinstance checks) and AC10 (ModelId.parse). Tests import from interfaces.py.\n\n## Files Owned\n- tests/test_interfaces.py\n\n## Acceptance Criteria\nGiven test suite when run then Protocol compliance verified, ModelId parsing verified should never accept invalid model IDs","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:43Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:47:28Z","closed_at":"2026-02-22T01:47:28Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-exe","depends_on_id":"aura-plugins-1cy","type":"blocks","created_at":"2026-02-21T17:32:44Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-g2a","title":"SLICE-1-TESTS: test_aura_types.py + test_schema_types_sync.py","description":"---\nreferences:\n  slice: aura-plugins-35d\n  impl_plan: aura-plugins-06g\n---\n## Scope\nWrite test_aura_types.py (enum completeness, spec freezing, PHASE_DOMAIN mapping) and test_schema_types_sync.py (integration test: Python types match schema.xml entities).\n\n## Files Owned\n- tests/test_aura_types.py\n- tests/test_schema_types_sync.py\n\n## Acceptance Criteria\nGiven test suite when run then all tests pass, enum completeness verified, schema.xml sync verified should never allow drift between Python types and schema.xml","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:37Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:42:53Z","closed_at":"2026-02-22T01:42:53Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-g2a","depends_on_id":"aura-plugins-9nc","type":"blocks","created_at":"2026-02-21T17:32:37Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-gbr","title":"ELICIT: SessionEntry orchestration — A2A/MCP-compliant protocol engine","description":"---\nreferences:\n  request: aura-plugins-bj1\n---\n\n## Questions and Responses\n\n### Round 1: End Vision\nQ: What is the end vision for transcript data? What will consumers DO with stored TranscriptEntries?\nOptions: Agent observability (Debug agent behavior), Analytics pipeline (Aggregate metrics), Training/fine-tuning data (Export for ML), Audit trail / compliance (Immutable record)\nA: ALL OF THE ABOVE. User notes: \"The exact end-goal vision is at ~/dev/agent-data-leverage/david-data-ingestion-typescript-pipeline/initial-collaboration-protocol.md and ~/dev/agent-data-leverage/david-data-ingestion-typescript-pipeline/nlp-project-proposal.md\"\n\n### Round 1: MVP Harnesses\nQ: Which model harnesses should the MVP support?\nOptions: Claude Code (JSONL transcripts), OpenCode (ACP messages), Generic JSON-RPC/MCP (future harnesses), Raw transcript files (heuristic parsing)\nA: Generic JSON-RPC/MCP, OpenCode, Claude Code. User notes: \"I already have an ACP compliant JSON-RPC 2.0 tool call filterer at ~/codebases/dayvidpham/agentfilter. However, this transcript parser is WIP and being built by me and others separately at ~/dev/agent-data-leverage/unified-schema, we can delegate to their implementation. We don't need to support transcript parsing so much, just orchestration. For the orchestration aspect, we can utilize some prior work done at ~/codebases/dayvidpham/nix-openclaw-vm/docs/research/temporal*.Rmd. They also have some usage of Temporal already.\"\n\n### Round 2: Orchestration Scope\nQ: What does 'orchestration' mean concretely here?\nOptions: Aura protocol workflow engine (12-phase machine-executable), Multi-harness pipeline coordinator (Temporal activities for ingestion), SessionEntry enrichment pipeline (post-ingestion tagging), Cross-project integration layer (bridge all projects)\nA: Aura protocol workflow engine + Cross-project integration layer. User notes: \"The cross-project integration layer is the end-goal vision, with a completely auditable agent workflow to improve open-source development, affecting the future of work for developers, and establishing a better integration layer for agents in the knowledge commons.\"\n\n### Round 2: Code Location\nQ: Where should the SessionEntry database design live?\nOptions: unified-schema (extend existing), aura-plugins (new module), New repo, nix-openclaw-vm (extend Temporal)\nA: unified-schema (extend existing). User notes: \"So because their team is handling it, we don't have to worry about it here. Should NOT modify any files outside of this repo.\"\n\n### Round 2: Schema Strategy\nQ: For the variant-rich schema problem: extend typed enum or delta composition?\nOptions: Extend typed enum (pragmatic), Delta composition (research-informed), Hybrid (recommended by research)\nA: Hybrid (recommended by research)\n\n### Round 3: MVP for Machine-Executable Protocol\nQ: What is the MVP for making the 12-phase protocol machine-executable?\nOptions: Constraint validator + state machine, Temporal workflow engine, Code generation from schema.xml, Schema.xml → runtime context injection\nA: User specified a 3-version roadmap:\n  v1: Constraint validator + state machine, built with Temporal (Python SDK)\n  v2: Schema.xml → runtime context injection (single source of truth, no SKILL.md drift)\n  v3: Full Temporal workflow engine (phases as workflows, handoffs as signals, constraints as activity guards)\nUser notes: \"Temporal used throughout though.\"\n\n### Round 3: Catch-All\nQ: Anything else about end vision, constraints, or integration points?\nOptions: Temporal is the target runtime, Must stay Python-only in aura-plugins, Beads is the task coordination layer, Nothing else\nA: Temporal is the target runtime + Must stay Python-only. User notes: \"Temporal has a Python SDK as well. Beads is what we will use for now. Eventually, should be superseded by our own solution that may utilize the APIs we develop. Temporal natively interfaces with a database for its audit trail and logging, so will be very useful here.\"","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T00:38:31Z","created_by":"David Huu Pham","updated_at":"2026-02-22T00:38:31Z","labels":["aura:p2-user:s2_1-elicit"],"dependencies":[{"issue_id":"aura-plugins-gbr","depends_on_id":"aura-plugins-gmv","type":"blocks","created_at":"2026-02-21T16:58:15Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-gbr","depends_on_id":"aura-plugins-umi","type":"blocks","created_at":"2026-02-21T16:39:11Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-gdx","title":"SLICE-5-REVIEW-C-1 IMPORTANT","description":"Reviewer C (Elegance) — SLICE-5 IMPORTANT severity group.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:47Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:20:47Z","labels":["aura:p10-impl:s10-review","aura:severity:important"],"dependencies":[{"issue_id":"aura-plugins-gdx","depends_on_id":"aura-plugins-i2g","type":"blocks","created_at":"2026-02-21T18:22:00Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-gmv","title":"PROPOSAL-1: Machine-executable aura protocol engine v1 MVP — state machine + Temporal + constraint validators","description":"---\nreferences:\n  request: aura-plugins-bj1\n  urd: aura-plugins-umi\n  elicit: aura-plugins-gbr\n  related_epoch: aura-plugins-220\n---\n\n## Problem Space\n\n**Axes:** state machine (sequential with branching), constraint enforcement (transition-time), durability (Temporal), forensic queryability (search attributes), variant-rich integration (typed protocol/ABC interfaces)\n\n**Has-a / Is-a relationships:**\n- Epoch HAS-A state machine (12-phase lifecycle)\n- State machine HAS-A transition table (derived from schema.xml phase/transition definitions)\n- Epoch HAS-MANY constraint validators (structural, referential, semantic, runtime)\n- Temporal workflow IS-A durable wrapper around the state machine\n- PhaseId IS-A str Enum; Domain IS-A str Enum; RoleId IS-A str Enum (all typed)\n- ConstraintValidator IS-A Protocol (integration interface for cross-project)\n\n**Key insight:** The transition rules already exist in schema.xml (each `\u003cphase\u003e` has `\u003ctransitions\u003e` with `to-phase` and `condition`). For v1, we codify these as Python typed enums and a transition table. For v2, we parse schema.xml at runtime.\n\n## Engineering Tradeoffs\n\n| Decision | Options | Choice | Rationale |\n|----------|---------|--------|-----------|\n| State machine library | `transitions` lib / hand-rolled / `statemachine` lib | Hand-rolled dataclass + dict | Schema.xml defines exactly 12 phases with known transitions. A library adds dependency weight with no benefit for a fixed-topology machine. Simpler to test. |\n| Temporal workflow granularity | One workflow per epoch / one per phase | One per epoch (v1) | Per-epoch is sufficient for v1. Signals handle phase advances. Per-phase parallelism is v3 scope. |\n| Schema-to-code derivation | Parse schema.xml at runtime (v2) / codify transitions in Python (v1) | Python typed enums + frozen dataclass specs (v1) | Runtime parsing is v2 scope. For v1, we define the transition table as code, validated against schema.xml by integration tests. |\n| Constraint enforcement timing | Transition-time only / continuous polling | Transition-time only (v1) | Simpler, deterministic, sufficient. Constraints are checked when `advance_phase()` is called. |\n| Type system | Pydantic / dataclasses / attrs | dataclasses (frozen) | No Pydantic dependency currently. Frozen dataclasses provide immutability + type safety. Temporal SDK works with dataclasses natively. |\n| Package location | `scripts/aura_protocol/` / `src/aura_protocol/` | `scripts/aura_protocol/` | Consistent with existing `pythonpath = [\"scripts\"]` in pyproject.toml. `validate_schema` already lives in `scripts/`. |\n| Integration interfaces | Abstract Base Classes / `typing.Protocol` | `typing.Protocol` (runtime_checkable) | Structural subtyping — external projects don't need to inherit from our base classes. More Pythonic, better for cross-repo integration where we can't control the other side. |\n| A2A/MCP types scope | Full A2A type hierarchy / minimal content types | Minimal: Part union + TaskState + tool call types | v1 needs just enough for interface definitions. Full hierarchy is v2/v3 scope. |\n\n## MVP Milestone (v1)\n\n### Scope\n5 Python modules + corresponding tests, extending the existing validate_schema.py patterns:\n\n### Module 1: `scripts/aura_protocol/types.py` — Protocol Type Definitions\nTyped enums and frozen dataclass specs for all protocol entities. Derived from schema.xml but codified in Python.\n\n```python\nclass Domain(str, Enum):\n    USER = \"user\"\n    PLAN = \"plan\"\n    IMPL = \"impl\"\n\nclass PhaseId(str, Enum):\n    P1_REQUEST = \"p1\"\n    P2_ELICIT = \"p2\"\n    P3_PROPOSE = \"p3\"\n    P4_REVIEW = \"p4\"\n    P5_UAT = \"p5\"\n    P6_RATIFY = \"p6\"\n    P7_HANDOFF = \"p7\"\n    P8_IMPL_PLAN = \"p8\"\n    P9_SLICE = \"p9\"\n    P10_CODE_REVIEW = \"p10\"\n    P11_IMPL_UAT = \"p11\"\n    P12_LANDING = \"p12\"\n    COMPLETE = \"complete\"\n\nclass RoleId(str, Enum):\n    EPOCH = \"epoch\"\n    ARCHITECT = \"architect\"\n    REVIEWER = \"reviewer\"\n    SUPERVISOR = \"supervisor\"\n    WORKER = \"worker\"\n\nclass VoteType(str, Enum):\n    ACCEPT = \"ACCEPT\"\n    REVISE = \"REVISE\"\n\nclass SeverityLevel(str, Enum):\n    BLOCKER = \"BLOCKER\"\n    IMPORTANT = \"IMPORTANT\"\n    MINOR = \"MINOR\"\n\n# Phase-domain mapping (from schema.xml semantic rule _EXPECTED_DOMAINS)\nPHASE_DOMAIN: dict[PhaseId, Domain]\n\n# Frozen spec dataclasses\n@dataclass(frozen=True)\nclass Transition:\n    to_phase: PhaseId\n    condition: str\n    action: str | None = None\n\n@dataclass(frozen=True)\nclass PhaseSpec:\n    id: PhaseId\n    number: int\n    domain: Domain\n    name: str\n    owner_roles: frozenset[RoleId]\n    transitions: tuple[Transition, ...]\n\n@dataclass(frozen=True)\nclass ConstraintSpec:\n    id: str\n    given: str\n    when: str\n    then: str\n    should_not: str\n\n@dataclass(frozen=True)\nclass HandoffSpec:\n    id: str\n    source_role: RoleId\n    target_role: RoleId\n    at_phase: PhaseId\n    content_level: str\n    required_fields: tuple[str, ...]\n\n# Canonical protocol definition — the transition table\nPHASE_SPECS: dict[PhaseId, PhaseSpec]\nCONSTRAINT_SPECS: dict[str, ConstraintSpec]\nHANDOFF_SPECS: dict[str, HandoffSpec]\n```\n\n### Module 2: `scripts/aura_protocol/state_machine.py` — 12-Phase State Machine\nManages epoch lifecycle state and validates transitions against the protocol.\n\n```python\n@dataclass\nclass EpochState:\n    \"\"\"Mutable epoch runtime state.\"\"\"\n    current_phase: PhaseId\n    completed_phases: set[PhaseId]\n    review_votes: dict[str, VoteType]  # \"{axis}\" -\u003e vote\n    blocker_count: int\n    current_role: RoleId\n    epoch_id: str\n    transition_history: list[TransitionRecord]\n\n@dataclass(frozen=True)\nclass TransitionRecord:\n    from_phase: PhaseId\n    to_phase: PhaseId\n    timestamp: datetime\n    triggered_by: str  # role or signal name\n    condition_met: str\n\nclass TransitionError(Exception):\n    \"\"\"Raised when a transition is invalid.\"\"\"\n    violations: list[str]\n\nclass EpochStateMachine:\n    def __init__(self, epoch_id: str, specs: dict[PhaseId, PhaseSpec] | None = None): ...\n    \n    def advance(self, to_phase: PhaseId, *, triggered_by: str, condition_met: str) -\u003e TransitionRecord:\n        \"\"\"Advance to next phase. Raises TransitionError if invalid.\"\"\"\n    \n    def validate_advance(self, to_phase: PhaseId) -\u003e list[str]:\n        \"\"\"Dry-run: returns list of violation messages (empty = valid).\"\"\"\n    \n    def record_vote(self, axis: str, vote: VoteType) -\u003e None:\n        \"\"\"Record a reviewer vote (p4 or p10).\"\"\"\n    \n    def has_consensus(self) -\u003e bool:\n        \"\"\"True if all 3 review axes have ACCEPT votes.\"\"\"\n    \n    def record_blocker(self, *, resolved: bool = False) -\u003e None:\n        \"\"\"Track BLOCKER count for code review gating.\"\"\"\n    \n    @property\n    def state(self) -\u003e EpochState: ...\n    \n    @property\n    def available_transitions(self) -\u003e list[Transition]: ...\n```\n\n### Module 3: `scripts/aura_protocol/constraints.py` — Runtime Constraint Validators\nExtends the validate_schema.py pattern for runtime state checking.\n\n```python\n@dataclass(frozen=True)\nclass ConstraintViolation:\n    constraint_id: str\n    message: str\n    context: dict[str, str]\n\nclass RuntimeConstraintChecker:\n    \"\"\"Checks protocol constraints against current epoch state.\"\"\"\n    \n    def __init__(self, constraint_specs: dict[str, ConstraintSpec] | None = None): ...\n    \n    def check_all(self, state: EpochState) -\u003e list[ConstraintViolation]:\n        \"\"\"Run all constraint checks against current state.\"\"\"\n    \n    def check_transition(self, state: EpochState, to_phase: PhaseId) -\u003e list[ConstraintViolation]:\n        \"\"\"Check constraints specific to a proposed transition.\"\"\"\n    \n    def check_review_consensus(self, state: EpochState) -\u003e list[ConstraintViolation]:\n        \"\"\"C-review-consensus: all 3 must ACCEPT.\"\"\"\n    \n    def check_dep_direction(self, parent_id: str, child_id: str) -\u003e list[ConstraintViolation]:\n        \"\"\"C-dep-direction: parent blocked-by child.\"\"\"\n    \n    def check_severity_tree(self, state: EpochState) -\u003e list[ConstraintViolation]:\n        \"\"\"C-severity-eager: 3 groups must exist for p10.\"\"\"\n    \n    def check_handoff_required(self, from_phase: PhaseId, to_phase: PhaseId) -\u003e list[ConstraintViolation]:\n        \"\"\"C-handoff-skill-invocation: handoff doc required for actor changes.\"\"\"\n```\n\n### Module 4: `scripts/aura_protocol/workflow.py` — Temporal Workflow Definition\nDurable execution wrapper around the state machine.\n\n```python\nfrom temporalio import workflow, activity\nfrom temporalio.common import SearchAttributeKey, TypedSearchAttributes\n\n# Search attributes for forensic queries (R4)\nSA_EPOCH_ID = SearchAttributeKey.for_text(\"AuraEpochId\")\nSA_PHASE = SearchAttributeKey.for_keyword(\"AuraPhase\")\nSA_ROLE = SearchAttributeKey.for_keyword(\"AuraRole\")\nSA_STATUS = SearchAttributeKey.for_keyword(\"AuraStatus\")\nSA_DOMAIN = SearchAttributeKey.for_keyword(\"AuraDomain\")\n\n@dataclass(frozen=True)\nclass EpochInput:\n    epoch_id: str\n    request_description: str\n\n@dataclass(frozen=True) \nclass EpochResult:\n    epoch_id: str\n    final_phase: PhaseId\n    transition_count: int\n    constraint_violations_total: int\n\n@dataclass(frozen=True)\nclass PhaseAdvanceSignal:\n    to_phase: PhaseId\n    triggered_by: str\n    condition_met: str\n\n@dataclass(frozen=True)\nclass ReviewVoteSignal:\n    axis: str  # \"A\", \"B\", \"C\"\n    vote: VoteType\n    reviewer_id: str\n\n@workflow.defn\nclass EpochWorkflow:\n    \"\"\"Temporal workflow for a single epoch lifecycle.\n    \n    The workflow wraps EpochStateMachine and exposes:\n    - Signals for phase advances and review votes\n    - Queries for current state\n    - Search attributes for forensic queries\n    \"\"\"\n    \n    @workflow.run\n    async def run(self, input: EpochInput) -\u003e EpochResult:\n        \"\"\"Wait for signals to advance through phases until COMPLETE.\"\"\"\n    \n    @workflow.signal\n    async def advance_phase(self, signal: PhaseAdvanceSignal) -\u003e None:\n        \"\"\"Signal to advance to the next phase.\"\"\"\n    \n    @workflow.signal\n    async def submit_vote(self, signal: ReviewVoteSignal) -\u003e None:\n        \"\"\"Signal to record a review vote.\"\"\"\n    \n    @workflow.query\n    def current_state(self) -\u003e EpochState:\n        \"\"\"Query current epoch state.\"\"\"\n    \n    @workflow.query\n    def available_transitions(self) -\u003e list[Transition]:\n        \"\"\"Query available transitions from current phase.\"\"\"\n\n@activity.defn\nasync def check_constraints(state: EpochState, to_phase: PhaseId) -\u003e list[ConstraintViolation]:\n    \"\"\"Activity to run constraint checks (allows retry on transient failures).\"\"\"\n\n@activity.defn\nasync def record_transition(record: TransitionRecord) -\u003e None:\n    \"\"\"Activity to persist transition to audit trail.\"\"\"\n```\n\n### Module 5: `scripts/aura_protocol/interfaces.py` — Cross-Project Integration Interfaces\nPython Protocols for variant-rich integration.\n\n```python\nfrom typing import Protocol, runtime_checkable\n\n@runtime_checkable\nclass ConstraintValidatorInterface(Protocol):\n    \"\"\"Any constraint validator must implement this.\"\"\"\n    def validate(self, state: EpochState) -\u003e list[ConstraintViolation]: ...\n\n@runtime_checkable\nclass TranscriptRecorder(Protocol):\n    \"\"\"Interface for unified-schema integration (transcript recording).\n    \n    Implementors live in unified-schema; we only define the contract.\n    \"\"\"\n    async def record_phase_transition(self, event: PhaseTransitionEvent) -\u003e None: ...\n    async def record_constraint_check(self, event: ConstraintCheckEvent) -\u003e None: ...\n    async def record_review_vote(self, event: ReviewVoteEvent) -\u003e None: ...\n\n@runtime_checkable\nclass SecurityGate(Protocol):\n    \"\"\"Interface for agentfilter integration (permission checking).\n    \n    Implementors live in agentfilter; we only define the contract.\n    \"\"\"\n    async def check_tool_permission(self, request: ToolPermissionRequest) -\u003e PermissionDecision: ...\n\n@runtime_checkable\nclass AuditTrail(Protocol):\n    \"\"\"Interface for the audit trail backend.\n    \n    v1: backed by Beads (bd CLI).\n    v2+: backed by Temporal event history + search attributes.\n    \"\"\"\n    async def record_event(self, event: AuditEvent) -\u003e None: ...\n    async def query_events(self, *, phase: PhaseId | None = None, role: RoleId | None = None) -\u003e list[AuditEvent]: ...\n\n# A2A-compatible content types (minimal subset for v1)\n@dataclass(frozen=True)\nclass TextPart:\n    \"\"\"A2A TextPart — text content.\"\"\"\n    text: str\n\n@dataclass(frozen=True)\nclass FilePart:\n    \"\"\"A2A FilePart — file content reference.\"\"\"\n    file_uri: str\n    mime_type: str | None = None\n\n@dataclass(frozen=True)\nclass DataPart:\n    \"\"\"A2A DataPart — structured data.\"\"\"\n    data: dict\n\nPart = TextPart | FilePart | DataPart  # A2A Part discriminated union\n\n@dataclass(frozen=True)\nclass ToolCall:\n    \"\"\"MCP-compatible tool call representation.\"\"\"\n    tool_name: str\n    tool_input: dict\n    tool_output: dict | None = None\n\n@dataclass(frozen=True)\nclass ModelId:\n    \"\"\"models.dev composite identifier: {provider_id}/{model_id}.\"\"\"\n    provider: str\n    model: str\n    \n    def __str__(self) -\u003e str:\n        return f\"{self.provider}/{self.model}\"\n    \n    @classmethod\n    def parse(cls, s: str) -\u003e \"ModelId\":\n        provider, _, model = s.partition(\"/\")\n        if not model:\n            raise ValueError(f\"Invalid model ID: {s!r} (expected 'provider/model')\")\n        return cls(provider=provider, model=model)\n```\n\n### File Tree (New Files)\n\n```\nscripts/\n  aura_protocol/                  # NEW package\n    __init__.py                   # Re-exports public API\n    types.py                      # Typed enums, frozen dataclass specs\n    state_machine.py              # EpochStateMachine + EpochState\n    constraints.py                # RuntimeConstraintChecker\n    workflow.py                   # Temporal EpochWorkflow + activities\n    interfaces.py                 # Protocol/ABC for cross-project integration\ntests/\n  test_aura_types.py              # NEW: enum coverage, spec completeness\n  test_state_machine.py           # NEW: transition validation, review gates\n  test_constraints.py             # NEW: runtime constraint checking\n  test_workflow.py                # NEW: Temporal workflow (sandbox tests)\n  test_interfaces.py              # NEW: Protocol compliance verification\n  test_schema_types_sync.py       # NEW: integration test — Python types match schema.xml\n```\n\n### Dependencies\n\n```toml\n# pyproject.toml additions\n[project]\ndependencies = [\"temporalio\u003e=1.9.0\"]\n\n[project.optional-dependencies]\ndev = [\"pytest\u003e=8.0\", \"pytest-asyncio\u003e=0.24\"]\n```\n\n## Validation Checklist\n\n- [ ] All PhaseId enum values match schema.xml `\u003cphase\u003e` elements (integration test)\n- [ ] All Domain enum values match schema.xml `\u003cenum name=\"DomainType\"\u003e` (integration test)\n- [ ] All RoleId enum values match schema.xml `\u003crole\u003e` elements (integration test)\n- [ ] PHASE_DOMAIN mapping matches schema.xml semantic rule _EXPECTED_DOMAINS\n- [ ] Transition table covers all transitions in schema.xml `\u003ctransitions\u003e`\n- [ ] State machine rejects invalid transitions (not in transition table)\n- [ ] Review consensus gate requires exactly 3 ACCEPT votes (axes A, B, C)\n- [ ] BLOCKER resolution gate blocks p10→p11 transition\n- [ ] Constraint checker catches all C-* constraints from schema.xml\n- [ ] Temporal workflow advances state via signals only (deterministic)\n- [ ] Search attributes updated on every phase transition\n- [ ] Temporal queries return correct current state\n- [ ] All Protocol interfaces are runtime_checkable\n- [ ] ModelId.parse() validates provider/model format\n- [ ] A2A Part union covers TextPart, FilePart, DataPart\n- [ ] Existing validate_schema.py tests still pass (no regressions)\n- [ ] Integration test: Python PhaseSpec transitions match schema.xml transitions\n\n## BDD Acceptance Criteria\n\n### AC1: State Machine Transitions\n**Given** an epoch in phase P1 **when** advance(\"p2\") is called with valid context **then** state transitions to P2 and transition is recorded **should not** allow skipping phases (e.g., p1→p8)\n\n### AC2: Review Consensus Gate\n**Given** an epoch in phase P4 with votes {A: ACCEPT, B: ACCEPT} **when** advance(\"p5\") is called **then** TransitionError is raised with \"consensus\" violation **should not** proceed without all 3 ACCEPT votes\n\n### AC3: Review Revision Loop\n**Given** an epoch in phase P4 with any REVISE vote **when** checking available transitions **then** only p3 (create new proposal) is available **should not** allow advance to p5\n\n### AC4: BLOCKER Resolution Gate\n**Given** an epoch in phase P10 with blocker_count \u003e 0 **when** advance(\"p11\") is called **then** TransitionError is raised **should not** proceed to UAT with unresolved BLOCKERs\n\n### AC5: Constraint Enforcement\n**Given** a RuntimeConstraintChecker with all schema.xml constraints **when** checking state with a violation **then** returns ConstraintViolation with the constraint_id and descriptive message **should not** silently pass violations\n\n### AC6: Temporal Workflow Durability\n**Given** a running EpochWorkflow **when** advance_phase signal is received **then** state machine transitions and search attributes are updated atomically **should not** allow non-deterministic operations in workflow code\n\n### AC7: Forensic Query via Search Attributes\n**Given** a running EpochWorkflow at phase P9 **when** querying Temporal with filter AuraPhase=\"p9\" **then** the workflow is returned in results **should not** have stale search attributes\n\n### AC8: Schema-Types Synchronization\n**Given** the Python type definitions in types.py **when** compared against schema.xml entities **then** every PhaseId, Domain, RoleId, VoteType, and SeverityLevel has a corresponding schema.xml element **should not** drift from schema.xml\n\n### AC9: Integration Interface Compliance\n**Given** a class implementing TranscriptRecorder Protocol **when** checked with isinstance() **then** returns True if all methods match **should not** require subclassing (structural subtyping)\n\n### AC10: Model ID Parsing\n**Given** ModelId.parse(\"anthropic/claude-opus-4-6\") **when** parsed **then** provider=\"anthropic\" and model=\"claude-opus-4-6\" **should not** accept strings without \"/\" separator","design":"{\"validation_checklist\":[\"PhaseId matches schema.xml phases\",\"Domain matches DomainType enum\",\"RoleId matches schema.xml roles\",\"Transition table covers all schema.xml transitions\",\"Review consensus requires 3 ACCEPT votes\",\"BLOCKER gate blocks p10-\u003ep11\",\"Constraint checker covers all C-* constraints\",\"Temporal workflow uses signals only\",\"Search attributes updated on transitions\",\"Protocol interfaces are runtime_checkable\",\"ModelId validates provider/model format\",\"Existing tests pass (no regressions)\",\"Integration test: Python specs match schema.xml\"],\"acceptance_criteria\":[{\"given\":\"epoch in phase P1\",\"when\":\"advance(p2) with valid context\",\"then\":\"transitions to P2, records transition\"},{\"given\":\"epoch in P4 with 2 of 3 ACCEPT\",\"when\":\"advance(p5)\",\"then\":\"TransitionError raised\"},{\"given\":\"epoch in P10 with blockers\",\"when\":\"advance(p11)\",\"then\":\"TransitionError raised\"},{\"given\":\"RuntimeConstraintChecker\",\"when\":\"checking violated state\",\"then\":\"returns ConstraintViolation list\"},{\"given\":\"running EpochWorkflow\",\"when\":\"advance_phase signal\",\"then\":\"state and search attributes updated atomically\"},{\"given\":\"Python types\",\"when\":\"compared to schema.xml\",\"then\":\"all enums have corresponding elements\"}],\"tradeoffs\":[{\"decision\":\"Hand-rolled state machine vs library\",\"rationale\":\"Fixed 12-phase topology, library adds unnecessary dependency\"},{\"decision\":\"One workflow per epoch vs per phase\",\"rationale\":\"Per-epoch simpler for v1, per-phase is v3\"},{\"decision\":\"dataclasses vs Pydantic\",\"rationale\":\"No Pydantic dep, Temporal SDK native dataclass support\"},{\"decision\":\"typing.Protocol vs ABC\",\"rationale\":\"Structural subtyping for cross-repo integration\"}]}","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T00:58:11Z","created_by":"David Huu Pham","updated_at":"2026-02-22T00:58:11Z","labels":["aura:p3-plan:s3-propose","aura:p6-plan:s6-ratify"],"dependencies":[{"issue_id":"aura-plugins-gmv","depends_on_id":"aura-plugins-06g","type":"blocks","created_at":"2026-02-21T17:29:21Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-gmv","depends_on_id":"aura-plugins-7gm","type":"blocks","created_at":"2026-02-21T17:00:19Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-gmv","depends_on_id":"aura-plugins-b5m","type":"blocks","created_at":"2026-02-21T17:17:57Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-gmv","depends_on_id":"aura-plugins-dwy","type":"blocks","created_at":"2026-02-21T17:00:42Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-gmv","depends_on_id":"aura-plugins-jd9","type":"blocks","created_at":"2026-02-21T17:00:39Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-gmv","depends_on_id":"aura-plugins-qil","type":"blocks","created_at":"2026-02-21T17:17:00Z","created_by":"David Huu Pham","metadata":"{}"}],"comments":[{"id":4,"issue_id":"aura-plugins-gmv","author":"David Huu Pham","text":"Reviewer A (Correctness): VOTE: ACCEPT - Proposal faithfully addresses all 8 URD requirements within v1 scope. Transition table derived from schema.xml is sound (12 phases + COMPLETE sentinel, forward transitions + 4 revision loops). Temporal integration follows correct patterns (signals for mutations, queries for reads, activities for I/O, search attributes for forensics). All engineering tradeoffs are well-justified and internally consistent. Review consensus and BLOCKER gates correctly model schema.xml constraints. 3 minor non-blocking observations: (1) A2A TaskState enum noted in URD but absent from module definitions, (2) Temporal serialization of set/dict with enum keys is an implementation detail to handle, (3) follow-up lifecycle state machine reuse could be clarified. No BLOCKER issues found. Full review at aura-plugins-7gm.","created_at":"2026-02-22T01:00:26Z"},{"id":5,"issue_id":"aura-plugins-gmv","author":"David Huu Pham","text":"Reviewer C (Elegance): VOTE: ACCEPT - Design demonstrates proportionate complexity. 5-module decomposition maps to 5 orthogonal problem axes. str Enum + frozen dataclasses match fixed 12-phase topology without over-engineering. typing.Protocol for cross-repo integration avoids forced inheritance. Two minor under-specifications (event type stubs needed, vote key format ambiguous) are resolvable during implementation without proposal revision. No premature abstractions of consequence. Complexity proportional to innate problem structure. Review task: aura-plugins-jd9","created_at":"2026-02-22T01:00:45Z"},{"id":6,"issue_id":"aura-plugins-gmv","author":"David Huu Pham","text":"Reviewer B (Test quality): VOTE: ACCEPT - Test strategy is well-designed: (1) 6 test files properly cover all 5 modules + cross-module sync integration test. (2) test_schema_types_sync.py is the linchpin integration test preventing Python/schema.xml drift. (3) All 10 BDD acceptance criteria (AC1-AC10) map to testable observable outcomes (return values, exceptions, isinstance). (4) Temporal sandbox testing is the correct approach — SUT is not mocked. (5) Existing SchemaFixture mutation framework is naturally extended. Minor observation: recommend shared EpochState factory fixtures during implementation, but this is an implementation detail, not a plan deficiency. Review task: aura-plugins-dwy","created_at":"2026-02-22T01:00:53Z"},{"id":7,"issue_id":"aura-plugins-gmv","author":"David Huu Pham","text":"RATIFIED: All 3 reviewers ACCEPT (A: aura-plugins-7gm, B: aura-plugins-dwy, C: aura-plugins-jd9), UAT passed (aura-plugins-qil)","created_at":"2026-02-22T01:17:09Z"}]}
{"id":"aura-plugins-h21","title":"SLICE-1-REVIEW-A-1 MINOR","description":"Reviewer A (Correctness) — SLICE-1 (types.py, __init__.py) — MINOR findings.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:10Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:21:39Z","closed_at":"2026-02-22T02:21:39Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-h7x","title":"SLICE-1-REVIEW-C-1 MINOR","description":"Reviewer C (Elegance) — SLICE-1 MINOR severity group.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:28Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:20:28Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"],"dependencies":[{"issue_id":"aura-plugins-h7x","depends_on_id":"aura-plugins-n0n","type":"blocks","created_at":"2026-02-21T18:22:13Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-hls","title":"SLICE-4-REVIEW-A-1 MINOR: FilePart uses file_uri field name instead of A2A spec file_with_uri","description":"## Finding\n\n### Location\n`scripts/aura_protocol/interfaces.py`, `FilePart` dataclass (lines 157-162):\n\n```python\n@dataclass(frozen=True)\nclass FilePart:\n    '''A2A FilePart — file content reference by URI.'''\n    file_uri: str\n    mime_type: str | None = None\n```\n\n### Description\nThe proposal (RATIFIED_PLAN aura-plugins-gmv) specifies:\n\n```python\n@dataclass(frozen=True)\nclass FilePart:\n    '''A2A FilePart — file content reference.'''\n    file_uri: str\n    mime_type: str | None = None\n```\n\nThe actual A2A v1.0 spec (https://a2a-protocol.org/latest/definitions/) defines FilePart differently — it uses a `file` field (not `file_uri`) with a nested `FileWithBytes` or `FileWithUri` object. The proposal deliberately chose a simplified form.\n\nHowever, the field name `file_uri` is not aligned with the A2A spec's actual structure, which uses `file.uri`. This is noted in the proposal as a 'minimal v1 subset' — so the deviation is intentional and documented.\n\n### Risk\nMINOR — this is a known tradeoff documented in the proposal ('minimal v1 subset'). The field name deviation from the actual A2A spec means future migration to full A2A compliance will require a field rename. Given that the proposal rationale explicitly says 'Full hierarchy is v2/v3 scope,' this is appropriate for v1.\n\n### Suggestion\nAdd a TODO comment in the FilePart docstring: 'v1 simplification: uses flat file_uri field. Full A2A compliance (v2) requires nested FileWithUri structure per A2A spec.'  This makes the migration cost visible to future implementors.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:24:33Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:24:33Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-i2g","title":"SLICE-5-REVIEW-C-1-F1: Bare except Exception in workflow.run() silently discards TransitionError with no caller feedback","description":"## Finding\n\nIn workflow.py, the advance_phase processing loop uses a bare Exception catch (lines 269-272):\n\n    try:\n        record = self._sm.advance(...)\n    except Exception:\n        # TransitionError from invalid advance — skip, stay in current phase.\n        # The violation is already counted from the constraint check.\n        continue\n\nThis silently swallows the TransitionError and continues the loop. The caller (whoever sent the advance_phase signal) receives NO feedback that their signal was rejected. From the caller's perspective, the signal was delivered, but nothing happened — the workflow stays at the current phase with no indication of why.\n\n## Elegance Problem\nThis is a significant complexity-hiding design issue:\n1. The signal pattern (fire-and-forget) is correct for Temporal, but there is no mechanism to surface rejection back to the caller\n2. The comment 'The violation is already counted from the constraint check' conflates two separate concerns: (a) constraint checking before advance, and (b) state machine validation INSIDE advance. These can diverge (constraint checker checks a subset; state machine checks the full transition table).\n3. A caller who sends an invalid signal gets no acknowledgment. This makes debugging harder — was the signal received? Did it fail? Is the workflow stuck?\n\n## Impact\n- During p4 review with a REVISE vote, if a caller mistakenly signals advance to p5, the signal is silently dropped. The caller must query current_state() to discover nothing changed.\n- This violates the design goal of explicit error handling: the URD requires 'forensic queryability' but a failed transition is not recorded anywhere in the audit trail (transition_history only records successes).\n\n## Fix\nOne of:\n1. Add a separate signal (e.g. advance_rejected signal) that the workflow emits when a transition is rejected, so callers have a feedback mechanism\n2. Catch and re-raise as a more specific exception, or log the rejection at ERROR level with the specific violations\n3. Record failed transition attempts in a separate rejected_advances list on EpochState for audit purposes\n\nOption 3 requires the least structural change: add rejected_advances: list[RejectedAdvanceRecord] to EpochState and populate it in the except block. This satisfies the forensic audit requirement.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:58Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:21:58Z","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-in8","title":"SLICE-3-REVIEW-C-1-F1: check_severity_tree does not validate p10 eager-creation positive case","description":"## Finding\n\nIn constraints.py, check_severity_tree() only enforces the NEGATIVE case:\n- If at p4 (plan review), severity trees MUST NOT exist\n\nIt does NOT enforce the POSITIVE case:\n- If at p10 (code review), severity trees MUST be created eagerly\n\nThe docstring explicitly admits this:\n    'Note: EpochState does not have a severity_groups field in v1. This\n    check validates the protocol invariant: p4 must NOT have severity groups\n    (C-severity-eager), and p10 MUST have them (C-severity-eager).\n    The presence check at p10 requires external enforcement.'\n\nThe method name is check_severity_tree and is listed under 'Named Constraint Checks', implying it handles C-severity-eager. But it silently returns [] for p10 state (test_p10_returns_empty asserts this as CORRECT behavior, which confirms the gap).\n\n## Impact\n- C-severity-eager is only half-enforced: the negative rule (p4 prohibition) is checked, but the positive rule (p10 mandate) is not\n- A reviewer at p10 who forgets to create severity groups will not be caught by check_all()\n- The method name and its position in the public API implies full coverage, which is misleading\n\n## Fix\nTwo options:\n1. (Preferred) Add a severity_groups: frozenset[str] field to EpochState (empty by default) and check that it contains {BLOCKER, IMPORTANT, MINOR} when at p10\n2. Rename the method to check_severity_not_plan() to accurately reflect what it actually validates, and create a separate (incomplete/documented) check_severity_eager() stub\n\nOption 1 is more correct but requires an EpochState field change. Option 2 preserves v1 scope but fixes the misleading API surface.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:39Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:21:39Z","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-ipj","title":"SLICE-2-REVIEW-A-1 IMPORTANT: advance() timestamp can be silently overwritten by workflow layer","description":"## Finding\n\n### Location\n`scripts/aura_protocol/state_machine.py` — `advance()` method (line 221-232).\n`scripts/aura_protocol/workflow.py` — `run()` method (lines 276-285).\n\n### Description\nThe `EpochStateMachine.advance()` method creates a `TransitionRecord` using `datetime.now(tz=timezone.utc)` (non-deterministic) and appends it to `self._state.transition_history`. The workflow layer in `workflow.py` then REPLACES the last element in `transition_history` with a new `TransitionRecord` bearing `workflow.now()`:\n\n```python\n# workflow.py lines 284-285\nif self._sm.state.transition_history:\n    self._sm.state.transition_history[-1] = deterministic_record\n```\n\n### Problem\nThis creates a design seam where the state machine's internal audit trail (transition_history) can be post-hoc modified by the workflow layer without the state machine's knowledge or consent. The state machine's public API guarantees that appended TransitionRecords are as-returned from advance(), but the workflow mutates this directly.\n\nAdditionally, if the workflow logic between 'sm.advance() records timestamp' and 'workflow.now() replacement' is replayed by Temporal, the state machine will have already appended the real-time record. The replacement is correct in the fast path, but the design allows the state machine's audit trail to diverge from what advance() recorded if the replacement never runs (e.g., an exception between lines 264 and 285).\n\n### Risk\nThis is IMPORTANT (not BLOCKER) because: (1) the current tests pass and the happy path is correct; (2) the architecture decision to use datetime.now() in state_machine.py is documented as being overridden by the workflow layer; (3) no test exercises the exception path between advance() and the timestamp replacement.\n\n### Suggestion\nTwo cleaner approaches:\n1. **Preferred:** Remove `datetime.now()` from `EpochStateMachine.advance()` — accept an optional `timestamp` parameter (defaulting to `datetime.now()` only when not in a workflow context). The workflow would pass `workflow.now()` explicitly. This eliminates the post-hoc mutation entirely.\n2. **Alternative:** Move timestamp responsibility entirely to the workflow. State machine's `TransitionRecord` gets a sentinel timestamp; workflow replaces before appending to history. But this still requires mutation access.\n\nApproach 1 keeps the audit trail immutable at the state machine level and makes the seam explicit.\n\n### Impact\nAffects SLICE-2 (state_machine.py) and SLICE-5 (workflow.py). Primary ownership is SLICE-2 since advance() would need a timestamp param.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:22:21Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:21Z","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-j02","title":"FOLLOWUP_URE: Scope follow-up for aura_protocol v1 improvements","description":"---\nreferences:\n  followup_epic: aura-plugins-2tj\n  original_urd: aura-plugins-umi\n---\nScoping URE: determine which IMPORTANT/MINOR findings from code review round 1 to address.\n\n## Key Findings to Scope\n1. Timestamp coupling in advance() / workflow\n2. check_severity_tree() C-severity-eager enforcement gap\n3. Bare except in EpochWorkflow.run()\n4. check_all() only covers 5/22 constraints\n5. EpochState.current_role str vs RoleId\n6. Missing WorkflowEnvironment integration test\n7. Missing Protocol self-check test","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:27:36Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:27:36Z","labels":["aura:p2-user:s2_1-elicit"],"dependencies":[{"issue_id":"aura-plugins-j02","depends_on_id":"aura-plugins-s6i","type":"blocks","created_at":"2026-02-21T18:27:36Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-j2k","title":"REQUEST: Automated release tagging and version bumping for aura-plugins","description":"---\nverbatim_request: \"I need automated release tagging and version bumping for the Claude Code plugin.\"\nclassification:\n  scope: medium\n  complexity: medium\n  risk: low\n  domain_novelty: low\n---\n\n## User Request (Verbatim)\n\n\"I need automated release tagging and version bumping for the Claude Code plugin.\"\n\n## Phase 1 Findings\n\n### s1_1-classify\nScope: medium | Complexity: medium | Risk: low | Domain Novelty: low\n\n### s1_2-research\n- Git tag convention: vX.Y.Z (annotated tags) is industry standard\n- Semver: major, minor, patch\n- Pre-release checks: clean working tree, version consistency across files\n- Single Python script with argparse is sufficient for small projects\n- CHANGELOG: Keep a Changelog format\n- Post-release: push tag, optionally gh release create\n\n### s1_3-explore\n- 3 files need version updates: pyproject.toml, plugin.json, marketplace.json\n- marketplace.json has 2 version fields (metadata.version + plugins[0].version)\n- plugins[1].version (agentfilter) is external, must NOT be bumped\n- Currently out of sync: marketplace.json at 0.2.1, others at 0.2.2\n- No git tags exist\n- bin/ tools, flake.nix, README.md have no hardcoded versions","status":"open","priority":2,"issue_type":"task","assignee":"architect","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:10:12Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:10:12Z","labels":["aura:p1-user:s1_1-classify","aura:p1-user:s1_2-research","aura:p1-user:s1_3-explore"],"dependencies":[{"issue_id":"aura-plugins-j2k","depends_on_id":"aura-plugins-wqw","type":"blocks","created_at":"2026-02-21T12:10:26Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-j6h","title":"SLICE-4-REVIEW-B-1 BLOCKER","description":"Reviewer B (Test Quality) — SLICE-4 (interfaces.py) blocker-level findings.\n\n## Finding Summary\n\nNO BLOCKER findings for SLICE-4.\n\n- Tests import from production modules (aura_protocol.interfaces, aura_protocol.types).\n- SUT (Protocol interfaces, ModelId, Part types, ToolCall) are NOT mocked.\n- AC9 (isinstance structural subtyping) tested with concrete inline classes that inherit only from object — verifies no subclassing required.\n- AC10 (ModelId.parse) tested with 11 cases covering valid, invalid, edge cases, roundtrip, equality, and hashability.\n- Event stub re-exports verified as importable and frozen.\n- TYPE_CHECKING guard in interfaces.py means ConstraintViolation and EpochState are not imported at runtime — test_interfaces.py does NOT import these via aura_protocol.interfaces, which is the correct behavior.\n\nThis group is empty and will be closed immediately.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:22:15Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:40Z","closed_at":"2026-02-22T02:22:40Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-jd9","title":"PROPOSAL-1-REVIEW-C-1: aura protocol engine v1","description":"VOTE: ACCEPT - The design demonstrates proportionate complexity across all dimensions.\n\n## Axis C (Elegance) Assessment\n\n### Module Decomposition (5 modules): APPROPRIATE\nThe 5-module split (types, state_machine, constraints, workflow, interfaces) maps to 5 orthogonal concerns in the problem domain. No redundancy, no missing axis. Minor observation: A2A content types (TextPart/FilePart/DataPart/ToolCall/ModelId) in interfaces.py are data types, not interfaces — they could live in types.py. Not a structural issue.\n\n### Typed Enum Approach: EXACTLY RIGHT\nstr Enum provides forward-compatible serialization (strings serialize trivially to JSON/Temporal payloads) while maintaining compile-time type safety. The transition table as dict[PhaseId, PhaseSpec] with frozen dataclasses matches the fixed 12-phase topology without library overhead.\n\n### Integration Interfaces (typing.Protocol): CORRECT CHOICE\nruntime_checkable Protocol is the right abstraction for cross-repo integration where we don't control the other side. Avoids forcing inheritance. 4 Protocol definitions with zero implementation weight — just contracts.\n\n### A2A Content Types Subset: WELL-SCOPED\nTextPart/FilePart/DataPart/Part union/ToolCall/ModelId covers what v1 needs per URD R5. Omitting ResourceLinkPart is appropriate (MCP-specific, not needed for orchestration). ModelId with parse()/str() is clean.\n\n### Package Layout: CONSISTENT\nscripts/aura_protocol/ respects existing pythonpath = [\"scripts\"] in pyproject.toml. Test files follow existing flat tests/ convention.\n\n### Premature Abstractions: MINIMAL\nHandoffSpec and SecurityGate are the most \"premature\" elements, but they are lightweight declarations (frozen dataclass, Protocol) with zero implementation burden. Acceptable as forward-looking documentation.\n\n### Under-Specification: TWO MINOR ITEMS\n1. Event types for integration protocols (PhaseTransitionEvent, ConstraintCheckEvent, ReviewVoteEvent, AuditEvent, ToolPermissionRequest, PermissionDecision) are referenced but not defined. Should be listed as stub dataclasses.\n2. EpochState.review_votes key format is ambiguous — should clarify that axis letter (\"A\"/\"B\"/\"C\") is the canonical key (matches PROPOSAL-1-REVIEW-{axis}-{round} naming convention).\n\n### Conclusion\nNo over-engineering: no generic FSM library, no schema parser for v1, no Pydantic dependency. No under-engineering: frozen dataclasses for immutability, runtime_checkable for structural subtyping, integration test against schema.xml for drift detection. Complexity is proportional to the innate 12-phase, 5-role, 3-domain protocol structure. The two under-specification items are minor enough to resolve during implementation (L1: types layer) rather than requiring a proposal revision.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:00:36Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:00:36Z","labels":["aura:p4-plan:s4-review"]}
{"id":"aura-plugins-jjo","title":"SLICE-1-REVIEW: Code review for bin/aura-release","description":"---\nreferences:\n  slice: aura-plugins-e19\n---\n\n## Review Findings (all resolved)\n\n### BLOCKER (fixed)\n1. rollback() had `or True` guard causing git checkout on non-existent files → removed\n\n### IMPORTANT (fixed)\n2. --sync + --no-commit leaves files dirty → added warning message\n3. cmd_check drift marker compared to first dict value → now uses pyproject.toml as canonical reference\n4. write_pyproject_version raised false RuntimeError on re-run → switched to pre-check regex match\n\n### MINOR (acknowledged)\n5. commits_since drops commit bodies/trailers → documented limitation, spec does not require trailers\n6. working_tree_dirty drops old rename path → extremely unlikely scenario\n\nAll BLOCKER and IMPORTANT findings resolved in the implementation.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:23:41Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:23:41Z","labels":["aura:p10-impl:s10-review"]}
{"id":"aura-plugins-jwb","title":"SLICE-3-REVIEW-A-1 IMPORTANT: check_severity_tree does not enforce C-severity-eager (p10 must have 3 groups)","description":"## Finding\n\n### Location\n`scripts/aura_protocol/constraints.py`, `check_severity_tree()` method (lines 260-301).\n\n### Description\nThe proposal's validation checklist specifies:\n\u003e C-severity-eager: 3 groups must exist for p10\n\nThe URD (aura-plugins-umi) requirement R1 states the constraint validator should enforce workflow state transitions.\n\nThe CONSTRAINT_SPECS correctly defines C-severity-eager as:\n\u003e given: code review round (p10 only), when: starting review, then: ALWAYS create 3 severity group tasks (BLOCKER, IMPORTANT, MINOR) immediately\n\nHowever, `check_severity_tree()` for `PhaseId.P10_CODE_REVIEW` returns an **empty list** (no violation). The implementation documents this as intentional:\n\n```python\ndef test_p10_returns_empty(self) -\u003e None:\n    '''p10 is the correct phase for severity trees — no violation from check_severity_tree.'''\n    # check_severity_tree doesn't mandate creation — it prevents severity trees in p4\n    violations = checker.check_severity_tree(state)\n    assert violations == []\n```\n\n### Problem\nThe method is named `check_severity_tree` and belongs to the class `RuntimeConstraintChecker`. C-severity-eager mandates CREATION of 3 groups at p10. The implementation only prevents severity trees at p4 (C-severity-not-plan). The positive check — 'we ARE at p10, do the 3 groups exist?' — is entirely absent and delegated to 'external enforcement.'\n\nEpochState has no `severity_groups` field, so there is no way for the runtime checker to enforce C-severity-eager even if it wanted to. This is the root gap.\n\n### Risk\nIMPORTANT (not BLOCKER) because: (1) the code comment in the test accurately documents this design limitation; (2) reviewers using the constraint checker at p10 will not be alerted if they forget to create the 3 severity groups; (3) AC5 (RuntimeConstraintChecker returns ConstraintViolation for violations) is met for all OTHER constraints.\n\n### Suggestion\nAdd `severity_groups: frozenset[str] = field(default_factory=frozenset)` to `EpochState` in state_machine.py. Then `check_severity_tree` at p10 can check whether all 3 required groups are present. This would allow the constraint system to enforce C-severity-eager programmatically and makes the check complete.\n\nAlternatively, document explicitly that C-severity-eager is a procedural (process-level) constraint enforced only by the reviewer skill instructions, not by the runtime checker — but this should be called out in the constraint spec itself.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:23:21Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:23:21Z","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-la6","title":"SLICE-2: state_machine.py — 12-phase epoch lifecycle","description":"---\nreferences:\n  impl_plan: aura-plugins-06g\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n---\n## Specification\nManage epoch lifecycle state and validate transitions against the protocol. Pure Python — no Temporal dependency.\n\n### Key Types\n- EpochState (mutable runtime state)\n- TransitionRecord (frozen, immutable audit entry)\n- TransitionError (exception with violations list)\n- EpochStateMachine (main class)\n\n### Key Behaviors\n- advance(to_phase) — validates and executes transitions\n- validate_advance(to_phase) — dry-run validation\n- record_vote(axis, vote) — record reviewer votes\n- has_consensus() — check 3/3 ACCEPT\n- record_blocker(resolved) — track BLOCKER count\n- available_transitions property\n\n### Transition Rules (from schema.xml)\n- Sequential forward: p1→p2→p3→p4→p5→p6→p7→p8→p9→p10→p11→p12→complete\n- Review revision loops: p4→p3 (REVISE), p10→p9 (BLOCKER fix)\n- Consensus gate: p4→p5 requires 3 ACCEPT, p5→p6 requires UAT pass\n- BLOCKER gate: p10→p11 requires blocker_count == 0\n\n## Files Owned\n- scripts/aura_protocol/state_machine.py (NEW)\n- tests/test_state_machine.py (NEW)\n\n## Acceptance Criteria\n- AC1: Given epoch in P1 when advance(p2) then transitions, records transition should not allow p1→p8\n- AC2: Given epoch in P4 with 2/3 ACCEPT when advance(p5) then TransitionError should not proceed without consensus\n- AC3: Given epoch in P4 with REVISE when checking transitions then only p3 available\n- AC4: Given epoch in P10 with blockers when advance(p11) then TransitionError should not proceed to UAT\n\n## Validation Checklist\n- [ ] EpochState dataclass defined\n- [ ] TransitionRecord frozen dataclass\n- [ ] TransitionError with violations list\n- [ ] EpochStateMachine class with all methods\n- [ ] Tests cover AC1-AC4\n- [ ] Transition table covers all schema.xml transitions","design":"{\"validation_checklist\":[\"State transitions validated\",\"Review consensus gate works\",\"BLOCKER resolution gate works\",\"Transition history recorded\"],\"acceptance_criteria\":[{\"given\":\"epoch in P1\",\"when\":\"advance(p2)\",\"then\":\"transitions to P2\"},{\"given\":\"epoch in P4 with 2/3 ACCEPT\",\"when\":\"advance(p5)\",\"then\":\"TransitionError raised\"},{\"given\":\"epoch in P10 with blockers\",\"when\":\"advance(p11)\",\"then\":\"TransitionError raised\"}],\"ratified_plan\":\"aura-plugins-gmv\"}","status":"closed","priority":2,"issue_type":"task","assignee":"worker-2","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:31:28Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:50:55Z","closed_at":"2026-02-22T01:50:55Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-la6","depends_on_id":"aura-plugins-0gt","type":"blocks","created_at":"2026-02-21T18:23:41Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-la6","depends_on_id":"aura-plugins-0n3","type":"blocks","created_at":"2026-02-21T17:32:39Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-la6","depends_on_id":"aura-plugins-125","type":"blocks","created_at":"2026-02-21T17:32:38Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-la6","depends_on_id":"aura-plugins-35d","type":"blocks","created_at":"2026-02-21T17:31:30Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-la6","depends_on_id":"aura-plugins-4mu","type":"blocks","created_at":"2026-02-21T17:32:38Z","created_by":"David Huu Pham","metadata":"{}"}],"comments":[{"id":14,"issue_id":"aura-plugins-la6","author":"David Huu Pham","text":"SLICE-2 complete. All 57 state_machine tests pass (264 total suite, zero regressions). Implemented: EpochState (mutable dataclass), TransitionRecord (frozen), TransitionError(Exception) with violations list, EpochStateMachine with advance(), validate_advance(), record_vote(), has_consensus(), record_blocker(), available_transitions property. All AC1-AC4 covered.","created_at":"2026-02-22T01:50:10Z"},{"id":22,"issue_id":"aura-plugins-la6","author":"David Huu Pham","text":"VOTE: ACCEPT - SLICE-2 (state_machine.py) implements all AC1-AC4 correctly. Phase transition table matches PHASE_SPECS from types.py; consensus gate (p4→p5 requires 3 ACCEPT); BLOCKER gate (p10→p11 requires blocker_count==0); revision loops (p4→p3 on REVISE, p10→p9 on REVISE); full sequential p1→COMPLETE completes in 12 transitions. Two non-blocking findings: (1) IMPORTANT: advance() uses datetime.now() and workflow layer post-hoc replaces the timestamp via direct list mutation — cleaner to pass timestamp as explicit parameter; (2) MINOR: current_role typed as str instead of RoleId, diverging from proposal spec. Neither finding blocks correctness of AC1-AC4. Tests confirm correct behavior for all gate scenarios.","created_at":"2026-02-22T02:22:47Z"},{"id":24,"issue_id":"aura-plugins-la6","author":"David Huu Pham","text":"VOTE: ACCEPT (Reviewer B - Test Quality)\n\nSLICE-2 (state_machine.py): Tests import from production modules only. EpochStateMachine is NOT mocked. All 4 BDD AC tests (AC1-AC4) present with thorough coverage of invalid transitions, consensus gate, revision loop, blocker gate. DI via constructor injection is tested and functional. Full sequential P1→COMPLETE lifecycle tested. Votes-cleared-after-transition behavior tested.\n\nSeverity groups: aura-plugins-919 (BLOCKER, empty/closed), aura-plugins-o83 (IMPORTANT: P10→P11 consensus gate is in constraint layer only, not _CONSENSUS_GATED in state machine — architectural split worth documenting), aura-plugins-v1b (MINOR: __import__ usage in DI test, _advance_to duplication across test files).\nNo BLOCKERs. ACCEPT.","created_at":"2026-02-22T02:23:35Z"}]}
{"id":"aura-plugins-lkk","title":"SLICE-3-REVIEW-C-1-F1: _SAME_ACTOR defined as local frozenset inside check_handoff_required method body","description":"## Finding\n\nIn constraints.py, check_handoff_required() defines _SAME_ACTOR as a local variable inside the method:\n\n    def check_handoff_required(self, from_phase: PhaseId, to_phase: PhaseId) -\u003e ...:\n        _SAME_ACTOR: frozenset[tuple[PhaseId, PhaseId]] = frozenset(\n            {\n                (PhaseId.P5_UAT, PhaseId.P6_RATIFY),\n                (PhaseId.P6_RATIFY, PhaseId.P7_HANDOFF),\n            }\n        )\n\nThis frozenset is recreated on every call to check_handoff_required(). Compare with the module-level _HANDOFF_REQUIRED_TRANSITIONS and _REVIEW_PHASES constants which are correctly defined at module scope.\n\n## Contrast\nAll other similar constants in constraints.py are module-level (lines 57-79):\n- _REVIEW_AXES: frozenset[str] = frozenset({'A', 'B', 'C'})\n- _REVIEW_PHASES: frozenset[PhaseId] = frozenset(...)\n- _HANDOFF_REQUIRED_TRANSITIONS: frozenset[...] = frozenset(...)\n\n_SAME_ACTOR should follow the same pattern.\n\n## Fix\nMove _SAME_ACTOR to module scope:\n    _SAME_ACTOR_TRANSITIONS: frozenset[tuple[PhaseId, PhaseId]] = frozenset(\n        {(PhaseId.P5_UAT, PhaseId.P6_RATIFY), (PhaseId.P6_RATIFY, PhaseId.P7_HANDOFF)}\n    )\nConsistent naming with _HANDOFF_REQUIRED_TRANSITIONS.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:22:22Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:22Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-lkz","title":"SLICE-5: workflow.py — Temporal workflow wrapper","description":"---\nreferences:\n  impl_plan: aura-plugins-06g\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n---\n## Specification\nTemporal workflow wrapping EpochStateMachine with durable execution. Signals for mutations, queries for reads, search attributes for forensics.\n\n### Key Types\n- EpochInput, EpochResult (frozen dataclasses)\n- PhaseAdvanceSignal, ReviewVoteSignal (frozen signal types)\n- Search attribute keys: SA_EPOCH_ID, SA_PHASE, SA_ROLE, SA_STATUS, SA_DOMAIN\n\n### Workflow\n- EpochWorkflow (@workflow.defn)\n  - run(input) — wait for signals, advance through phases\n  - advance_phase(signal) — signal handler\n  - submit_vote(signal) — signal handler\n  - current_state() — query\n  - available_transitions() — query\n\n### Activities\n- check_constraints(state, to_phase) — activity\n- record_transition(record) — activity\n\n### pyproject.toml Changes\n- Add temporalio\u003e=1.9.0 to [project].dependencies\n- Add pytest\u003e=8.0, pytest-asyncio\u003e=0.24 to [project.optional-dependencies].dev\n\n## Files Owned\n- scripts/aura_protocol/workflow.py (NEW)\n- tests/test_workflow.py (NEW)\n- pyproject.toml (MODIFY — add dependencies)\n\n## Acceptance Criteria\n- AC6: Given running EpochWorkflow when advance_phase signal then state + search attrs updated atomically should not have non-deterministic ops\n- AC7: Given workflow at P9 when querying AuraPhase=\"p9\" then workflow returned should not have stale attrs\n\n## Validation Checklist\n- [ ] EpochWorkflow with signals, queries, search attrs\n- [ ] Activities for constraint checking and transition recording\n- [ ] Temporal sandbox tests pass\n- [ ] pyproject.toml deps added\n- [ ] Search attributes updated on every transition","design":"{\"validation_checklist\":[\"Temporal workflow uses signals only\",\"Search attributes updated\",\"Sandbox tests pass\",\"pyproject.toml updated\"],\"acceptance_criteria\":[{\"given\":\"running EpochWorkflow\",\"when\":\"advance_phase signal\",\"then\":\"state and search attrs updated atomically\",\"should_not\":\"non-deterministic ops\"},{\"given\":\"workflow at P9\",\"when\":\"query AuraPhase=p9\",\"then\":\"workflow returned\",\"should_not\":\"stale search attrs\"}],\"ratified_plan\":\"aura-plugins-gmv\"}","status":"closed","priority":2,"issue_type":"task","assignee":"worker-5","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:31:30Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:17:12Z","closed_at":"2026-02-22T02:17:12Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-lkz","depends_on_id":"aura-plugins-2au","type":"blocks","created_at":"2026-02-21T17:32:47Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-lkz","depends_on_id":"aura-plugins-35d","type":"blocks","created_at":"2026-02-21T17:31:31Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-lkz","depends_on_id":"aura-plugins-amx","type":"blocks","created_at":"2026-02-21T17:32:46Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-lkz","depends_on_id":"aura-plugins-la6","type":"blocks","created_at":"2026-02-21T17:31:32Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-lkz","depends_on_id":"aura-plugins-mrm","type":"blocks","created_at":"2026-02-21T17:31:32Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-lkz","depends_on_id":"aura-plugins-r1n","type":"blocks","created_at":"2026-02-21T17:32:45Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-lkz","depends_on_id":"aura-plugins-z3n","type":"blocks","created_at":"2026-02-21T18:24:37Z","created_by":"David Huu Pham","metadata":"{}"}],"comments":[{"id":18,"issue_id":"aura-plugins-lkz","author":"David Huu Pham","text":"SLICE-5 complete. All tests pass.\n\nImplementation summary:\n- scripts/aura_protocol/workflow.py: EpochWorkflow (@workflow.defn) with signal-driven run() loop, advance_phase and submit_vote signals, current_state and available_transitions queries. Search attributes (SA_EPOCH_ID, SA_PHASE, SA_ROLE, SA_STATUS, SA_DOMAIN) upserted on every phase transition. Activities check_constraints and record_transition enforce the non-determinism boundary.\n- tests/test_workflow.py: 40 tests covering AC6 and AC7 via ActivityEnvironment (in-process, no server required) + structural introspection of Temporal decorators.\n- pyproject.toml: temporalio\u003e=1.9.0 added to [project].dependencies; pytest-asyncio\u003e=0.24 added to dev optional-dependencies.\n- All 458 tests pass (40 new + 418 prior slices). Zero regressions.\n\nNote on testing approach: WorkflowEnvironment.start_time_skipping() requires a Temporal test server binary (Go binary downloaded at runtime). Since no test server binary and no network were available in this Nix environment, workflow tests use ActivityEnvironment for activity tests and direct EpochStateMachine integration for AC6/AC7 logic validation — the same deterministic code path EpochWorkflow.run() executes.","created_at":"2026-02-22T02:16:37Z"},{"id":28,"issue_id":"aura-plugins-lkz","author":"David Huu Pham","text":"VOTE: ACCEPT (Reviewer B - Test Quality)\n\nSLICE-5 (workflow.py): Tests import from production modules including temporalio. EpochWorkflow and activities are NOT mocked. Temporal activities tested via ActivityEnvironment (correct in-process approach). Temporal decorator structure verified via introspection (pragmatic approach for CI without a Temporal binary). AC6/AC7 logic tested via state machine integration — documented as intentional with a clear upgrade path to WorkflowEnvironment.start_time_skipping() when a server is available. Search attribute keys verified for name and type.\n\nSeverity groups: aura-plugins-pbc (BLOCKER, empty/closed), aura-plugins-68o (IMPORTANT: no full WorkflowEnvironment sandbox test — AC6/AC7 Temporal wire-up is untested end-to-end), aura-plugins-sk6 (MINOR: _advance_to duplication, SA type distinction not asserted, SDK internal attribute usage).\nNo BLOCKERs. ACCEPT.","created_at":"2026-02-22T02:23:57Z"},{"id":34,"issue_id":"aura-plugins-lkz","author":"David Huu Pham","text":"VOTE: ACCEPT - SLICE-5 (workflow.py) correctly implements AC6 and AC7. EpochWorkflow uses @workflow.defn with signal-driven run() loop; advance_phase and submit_vote are @workflow.signal handlers; current_state() and available_transitions() are @workflow.query handlers; search attributes (SA_EPOCH_ID, SA_PHASE, SA_ROLE, SA_STATUS, SA_DOMAIN) are upserted on every transition; Temporal determinism is maintained (workflow.now() for timestamps, activities for I/O). The proposal's key design decision 'Temporal workflow uses signals only' is correctly implemented. Two non-blocking findings: (1) IMPORTANT: bare except Exception: in the advance handling should be except TransitionError: to avoid silently swallowing unexpected exceptions; (2) MINOR: SA_EPOCH_ID is omitted from the per-transition upsert (intentionally, since it's set-once) but this should be documented or made defensive.","created_at":"2026-02-22T02:25:46Z"}]}
{"id":"aura-plugins-m5o","title":"SLICE-1-REVIEW-C-1 IMPORTANT","description":"Reviewer C (Elegance) — SLICE-1 IMPORTANT severity group.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:27Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:23:04Z","closed_at":"2026-02-22T02:23:04Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-mki","title":"SLICE-3-REVIEW-C-1: constraints.py — Runtime constraint validators","description":"VOTE: ACCEPT\n\n## Review Summary (Reviewer C — Elegance and Complexity Proportionality)\n\nSLICE-3 (constraints.py) is the most complex slice and appropriately so: it carries all 22 C-* constraints, each with bespoke logic. The design choices are mostly sound.\n\n### Strengths\n- ConstraintViolation as a frozen dataclass (not an exception) is the correct design: return-value-based constraint reporting allows check_all() to aggregate all violations without short-circuiting. No exception-based control flow.\n- The split between check_all (aggregator), check_transition (transition-scoped), and named check_* methods is a clean public API. Users can call at the right granularity.\n- DI via optional constructor params mirrors EpochStateMachine — consistent pattern.\n- Structural constraints (C-agent-commit, C-dep-direction) are implemented as best-effort string validators with explicit documentation of what requires external enforcement. This is honest design — no pretense of full enforcement when the system boundary makes it impossible.\n- check_review_binary guards against GitHub-style vote vocabulary leaking in — a useful proactive constraint.\n- Module-level frozenset constants for _REVIEW_AXES, _REVIEW_PHASES, _HANDOFF_REQUIRED_TRANSITIONS are well-named and correctly scoped.\n- check_all does NOT short-circuit — all checks run. Correct for an audit-first design.\n\n### Important Finding\n- aura-plugins-in8: check_severity_tree does not validate the positive case of C-severity-eager (p10 must have severity groups). The method only enforces the negative prohibition (p4 must not). The public method name and position in the API imply full C-severity-eager coverage.\n\n### Minor Finding\n- aura-plugins-lkk: _SAME_ACTOR defined as a local frozenset inside check_handoff_required(). Inconsistent with all other module-level constants. Recreated on every call.\n\n### Verdict\nOne IMPORTANT finding (incomplete constraint enforcement — misleading API), one MINOR finding. No BLOCKERs. SLICE-3 ACCEPT — the IMPORTANT finding is architectural but does not break existing behavior, since the constraint is already partially enforced and the gap is documented.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:23:58Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:23:58Z","labels":["aura:p10-impl:s10-review"]}
{"id":"aura-plugins-mrm","title":"SLICE-3: constraints.py — Runtime constraint validators","description":"---\nreferences:\n  impl_plan: aura-plugins-06g\n  urd: aura-plugins-umi\n  proposal: aura-plugins-gmv\n---\n## Specification\nRuntime constraint checking engine. Extends validate_schema.py patterns for runtime state.\n\n### Key Types\n- ConstraintViolation (frozen dataclass: constraint_id, message, context dict)\n- RuntimeConstraintChecker (main class)\n\n### Key Behaviors\n- check_all(state) — run all constraints against EpochState\n- check_transition(state, to_phase) — check transition-specific constraints\n- check_review_consensus(state) — C-review-consensus\n- check_dep_direction(parent, child) — C-dep-direction\n- check_severity_tree(state) — C-severity-eager (3 groups for p10)\n- check_handoff_required(from_phase, to_phase) — C-handoff-skill-invocation\n\n### Constraints to Implement (from schema.xml C-* IDs)\nAll constraint IDs from schema.xml must have corresponding check methods.\n\n## Files Owned\n- scripts/aura_protocol/constraints.py (NEW)\n- tests/test_constraints.py (NEW)\n\n## Acceptance Criteria\n- AC5: Given RuntimeConstraintChecker when checking violated state then returns ConstraintViolation list should not silently pass\n\n## Validation Checklist\n- [ ] ConstraintViolation dataclass defined\n- [ ] RuntimeConstraintChecker class with all check methods\n- [ ] Tests cover all C-* constraints\n- [ ] check_all aggregates all violations\n- [ ] Each check method returns specific constraint_id","design":"{\"validation_checklist\":[\"All C-* constraints covered\",\"ConstraintViolation with context\",\"Aggregation via check_all\"],\"acceptance_criteria\":[{\"given\":\"RuntimeConstraintChecker\",\"when\":\"checking violated state\",\"then\":\"returns ConstraintViolation list\",\"should_not\":\"silently pass violations\"}],\"ratified_plan\":\"aura-plugins-gmv\"}","status":"closed","priority":2,"issue_type":"task","assignee":"worker-3","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:31:29Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:05:52Z","closed_at":"2026-02-22T02:05:52Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-mrm","depends_on_id":"aura-plugins-35d","type":"blocks","created_at":"2026-02-21T17:31:31Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-mrm","depends_on_id":"aura-plugins-9ii","type":"blocks","created_at":"2026-02-21T17:32:42Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-mrm","depends_on_id":"aura-plugins-eel","type":"blocks","created_at":"2026-02-21T17:32:40Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-mrm","depends_on_id":"aura-plugins-la6","type":"blocks","created_at":"2026-02-21T17:31:31Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-mrm","depends_on_id":"aura-plugins-mki","type":"blocks","created_at":"2026-02-21T18:24:01Z","created_by":"David Huu Pham","metadata":"{}"},{"issue_id":"aura-plugins-mrm","depends_on_id":"aura-plugins-w28","type":"blocks","created_at":"2026-02-21T17:32:41Z","created_by":"David Huu Pham","metadata":"{}"}],"comments":[{"id":16,"issue_id":"aura-plugins-mrm","author":"David Huu Pham","text":"SLICE-3 complete. All 418 tests pass (154 new in test_constraints.py + 264 pre-existing). Implemented: ConstraintViolation frozen dataclass, RuntimeConstraintChecker with check methods for all 22 C-* constraints. Production code path verified: no TODOs, all deps wired from types.py + state_machine.py. Committed: 7e3ad2d.","created_at":"2026-02-22T02:05:24Z"},{"id":25,"issue_id":"aura-plugins-mrm","author":"David Huu Pham","text":"VOTE: ACCEPT (Reviewer B - Test Quality)\n\nSLICE-3 (constraints.py): Tests import from production modules. RuntimeConstraintChecker is NOT mocked. AC5 (check_all aggregation, no short-circuit) is tested with dedicated class. All 22 C-* constraints have named test classes with positive and negative cases. Each violation tested for constraint_id, message content, and context fields. DI tested via custom constraint_specs and handoff_specs.\n\nSeverity groups: aura-plugins-nsl (BLOCKER, empty/closed), aura-plugins-yno (IMPORTANT: check_all only aggregates 5 of 22 constraints — the semantic contract of completeness is not documented or tested), aura-plugins-0yd (MINOR: weak OR assertion in message test, datetime.now() in TransitionRecord construction).\nNo BLOCKERs. ACCEPT.","created_at":"2026-02-22T02:23:42Z"},{"id":26,"issue_id":"aura-plugins-mrm","author":"David Huu Pham","text":"VOTE: ACCEPT - SLICE-3 (constraints.py) faithfully implements AC5 and all 22 C-* constraints. RuntimeConstraintChecker returns ConstraintViolation (never None, never raises), check_all aggregates without short-circuit, all constraint checks have matching constraint_ids, DI via constructor params works correctly. Two non-blocking findings: (1) IMPORTANT: check_severity_tree does not enforce C-severity-eager at p10 — EpochState lacks severity_groups field to enable runtime verification; (2) MINOR: check_blocker_gate uses constraint_id 'C-worker-gates' for the BLOCKER resolution gate, which conflates two distinct enforcement concerns. Neither blocks AC5 correctness.","created_at":"2026-02-22T02:23:47Z"}]}
{"id":"aura-plugins-n0n","title":"SLICE-1-REVIEW-C-1-F1: AuditEvent.payload typed as str (JSON-serialized) — loses type safety at audit boundary","description":"## Finding\n\nIn types.py, AuditEvent is defined as:\n\n    @dataclass(frozen=True)\n    class AuditEvent:\n        epoch_id: str\n        event_type: str\n        phase: PhaseId\n        role: RoleId\n        payload: str  # JSON-serialized event details\n\nThe payload field is typed str with a comment 'JSON-serialized event details'. This is stringly-typed: callers must manually serialize to JSON and consumers must manually deserialize, with no type guidance on the structure.\n\nGiven the existing typed event stubs (PhaseTransitionEvent, ConstraintCheckEvent, ReviewVoteEvent) are all frozen dataclasses, it would be more consistent to type payload as a union of the known event stubs, or at minimum as dict[str, Any].\n\n## Context\nThis is a v1 stub so some looseness is acceptable. The comment acknowledges the intent. However the pattern is inconsistent with the frozen dataclass approach used throughout types.py.\n\n## Fix\nConsider: payload: PhaseTransitionEvent | ConstraintCheckEvent | ReviewVoteEvent | dict[str, Any]\nOr create an AuditPayload union type that the AuditTrail interface can use for type-safe dispatch.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:22:11Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:11Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-nfr","title":"UAT-2: Implementation testing — UX issues found","description":"---\nreferences:\n  slice: aura-plugins-e19\n  review: aura-plugins-jjo\n---\n\n## UAT Result: ACCEPT with UX fixes needed\n\n### User Testing Logs (Verbatim)\n\nUser ran the following commands and found UX confusion:\n\n1. `python3 bin/aura-release` (no args) → error message says \"bump type required\" but doesn't show example usage\n2. `python3 bin/aura-release --dry-run` → confusing: fails asking for bump type, user expected it to show what current state is\n3. `python3 bin/aura-release --dry-run --sync` → same, fails asking for bump type\n4. `python3 bin/aura-release patch --dry-run` → fails with drift error, user didn't know --sync was needed alongside patch\n\n### User Feedback (Verbatim)\n- \"This was confusing: what does the program do when no subcommands or flags are given? How come the --dry-run kept failing? Error message is un-informative.\"\n- \"--check flag has good output and actionable output message.\"\n- \"--sync was confusing: only seasoned CLI users would know how to parse the message and know what was missing.\"\n- \"Good so far: should also have a message about what needs to be clean in the git worktree when syncing.\"\n\n### Issues to Fix\n1. No-args and missing-bump-type error messages need actionable examples\n2. Drift error needs to show the exact command to run (e.g., \"Try: aura-release patch --sync\")\n3. --sync should explain what needs to be clean in the git worktree\n4. Overall: error messages should guide the user to the next action","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:30:17Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:30:17Z","labels":["aura:p11-user:s11-uat"]}
{"id":"aura-plugins-ngd","title":"SLICE-4-REVIEW-A-1 IMPORTANT","description":"Reviewer A (Correctness) — SLICE-4 (interfaces.py) — IMPORTANT findings.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:23:53Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:23:53Z","labels":["aura:p10-impl:s10-review","aura:severity:important"],"dependencies":[{"issue_id":"aura-plugins-ngd","depends_on_id":"aura-plugins-zpu","type":"blocks","created_at":"2026-02-21T18:24:20Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-nq6","title":"SLICE-1-REVIEW-C-1 BLOCKER","description":"Reviewer C (Elegance) — SLICE-1 BLOCKER severity group. Findings to be added as children.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:24Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:56Z","closed_at":"2026-02-22T02:22:56Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-nsl","title":"SLICE-3-REVIEW-B-1 BLOCKER","description":"Reviewer B (Test Quality) — SLICE-3 (constraints.py) blocker-level findings.\n\n## Finding Summary\n\nNO BLOCKER findings for SLICE-3.\n\n- All test imports are from production modules (aura_protocol.constraints, aura_protocol.state_machine, aura_protocol.types).\n- SUT (RuntimeConstraintChecker) is NOT mocked. Tests instantiate the real checker.\n- Tests verify observable outcomes (return values: list[ConstraintViolation], exception types, constraint_id field values).\n- DI constructor tested: custom constraint_specs and handoff_specs accepted.\n- AC5 (check_all aggregation + no short-circuit) has dedicated test class with 7 tests.\n- All 22 C-* constraints covered by named test classes.\n- check_all does not cover ALL 22 individual constraint checkers (only check_review_consensus, check_severity_tree, check_blocker_gate, check_audit_trail, check_role_ownership are in check_all). The remaining 17 methods are utility checkers not auto-aggregated. This design is intentional per production code.\n\nThis group is empty and will be closed immediately.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:42Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:08Z","closed_at":"2026-02-22T02:22:08Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-o83","title":"SLICE-2-REVIEW-B-1 IMPORTANT","description":"Reviewer B (Test Quality) — SLICE-2 (state_machine.py) important-level findings.\n\n## Finding: P10→P11 consensus gate is not in _CONSENSUS_GATED — only _BLOCKER_GATED covers it — tests do not explicitly assert that P10→P11 without consensus raises TransitionError (IMPORTANT)\n\nThe state_machine.py defines:\n  _CONSENSUS_GATED = frozenset({(P4_REVIEW, P5_UAT)})\n\nP10→P11 is only in _BLOCKER_GATED. When blocker_count=0 and votes are present (all ACCEPT), the advance proceeds. But when blocker_count=0 and NO votes are recorded, the advance ALSO proceeds — there is no consensus enforcement on P10→P11 via the _CONSENSUS_GATED mechanism.\n\nThe _advance_to helper in test_state_machine.py satisfies P10→P11 by recording 3 ACCEPT votes AND clearing blockers, but there is no negative test that shows: 'at P10, blocker_count=0 but no votes → P11 advance succeeds (or should it fail?)'.\n\nThe proposal (AC4) states the BLOCKER gate blocks P10→P11. The CONSENSUS gate (AC2) only mentions P4→P5. However, test_state_machine.py:TestAC2ConsensusGate only tests P4. The check_constraints activity test (test_workflow.py line 273-289) DOES test p10→p11 consensus violation at the constraint layer.\n\nThis is an architectural inconsistency worth noting: the state machine allows P10→P11 without consensus (no consensus gate for P10), relying only on blocker_count. The constraint layer (RuntimeConstraintChecker.check_review_consensus) DOES flag p10 without consensus. The two layers are inconsistent in their enforcement boundary. This should be documented and aligned in a follow-up epic.\n\nSeverity: IMPORTANT (not BLOCKER) because the AC4 BDD acceptance criteria only state the BLOCKER gate blocks P10→P11, not a consensus gate. The behavior is intentional per the proposal, but creates confusion about where the p10 consensus is enforced.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:20Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:21:20Z","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-pbc","title":"SLICE-5-REVIEW-B-1 BLOCKER","description":"Reviewer B (Test Quality) — SLICE-5 (workflow.py) blocker-level findings.\n\n## Finding Summary\n\nNO BLOCKER findings for SLICE-5.\n\n- Tests import from production modules (aura_protocol.workflow, aura_protocol.constraints, aura_protocol.state_machine, aura_protocol.types, temporalio).\n- SUT (EpochWorkflow class and its activities check_constraints, record_transition) are NOT mocked.\n- AC6 and AC7 are tested via direct state machine integration (documented strategy) since a Temporal server binary is required for full sandbox tests and that dependency would block CI.\n- Activities are tested via ActivityEnvironment (in-process, no server required) — the correct Temporal testing approach for unit-level activity tests.\n- Temporal decorator introspection tests (TestWorkflowStructure) verify the @workflow.defn, @workflow.signal, @workflow.query, @workflow.run decorators are applied correctly without needing a full server.\n- All search attribute keys (SA_*) verified for name and type.\n\nThis group is empty and will be closed immediately.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:22:48Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:23:17Z","closed_at":"2026-02-22T02:23:17Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-pxo","title":"SLICE-3-REVIEW-C-1 MINOR","description":"Reviewer C (Elegance) — SLICE-3 MINOR severity group.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:38Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:20:38Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"],"dependencies":[{"issue_id":"aura-plugins-pxo","depends_on_id":"aura-plugins-lkk","type":"blocks","created_at":"2026-02-21T18:22:24Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-qil","title":"UAT-1: aura protocol engine v1 MVP plan","description":"---\nreferences:\n  proposal: aura-plugins-gmv\n  urd: aura-plugins-umi\n---\n## UAT Questions and Responses\n\n### Plan Presentation\nQ: Does this plan meet your requirements for v1 MVP? (5 modules in scripts/aura_protocol/, 6 test files, typed enums + frozen dataclasses, Temporal workflow, integration interfaces)\nOptions: Accept plan as-is (Proceed to ratification and implementation. All requirements satisfied.), Accept with notes (Plan is good but I have minor feedback to incorporate.), Request changes (Plan needs revision before proceeding.)\nA: User asked clarifying question: 'Is the state_machine.py defined using Temporal FSM primitives, or is it defined separately?'\n\n### Clarification: State Machine Architecture\nQ: Does this separation (pure Python state machine + Temporal workflow wrapper) meet your requirements?\nOptions: Accept plan as-is (Separation makes sense. Proceed to ratification and implementation.), Accept with notes (Good approach, but I have additional feedback.), Use Temporal primitives (I'd rather the state machine use Temporal's native patterns directly.)\nA: Accept plan as-is — Separation makes sense. Proceed to ratification and implementation.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:17:00Z","created_by":"David Huu Pham","updated_at":"2026-02-22T01:17:00Z","labels":["aura:p5-user:s5-uat"]}
{"id":"aura-plugins-qqf","title":"SLICE-3-REVIEW-A-1 MINOR: check_blocker_gate references C-worker-gates but semantically belongs to blocker resolution","description":"## Finding\n\n### Location\n`scripts/aura_protocol/constraints.py`, `check_blocker_gate()` method (lines 353-377).\n\n### Description\nThe method `check_blocker_gate` returns a `ConstraintViolation` with `constraint_id='C-worker-gates'`. However, `C-worker-gates` in CONSTRAINT_SPECS is defined as:\n\n\u003e given: worker finishes implementation, when: signaling completion, then: run quality gates (typecheck + tests) AND verify production code path\n\nThis constraint is about worker completion gates (typecheck + tests + no TODOs), NOT about the p10→p11 BLOCKER resolution gate. The BLOCKER gate is actually part of `C-review-consensus` or could be argued to belong to a dedicated `C-blocker-gate` constraint.\n\nMeanwhile, the dedicated method `check_worker_gates(has_todos, tests_pass, typecheck_pass)` ALSO uses `C-worker-gates` for a different purpose (worker quality gates).\n\nThis means a consumer calling `check_all(state)` at p10 with blockers will receive a `C-worker-gates` violation that conflates two different enforcement concerns under the same constraint ID.\n\n### Severity\nMINOR — no functional bug. Tests correctly verify the violation is raised. The constraint_id mismatch is a naming/categorization issue.\n\n### Suggestion\nIntroduce a dedicated `C-blocker-resolution-gate` constraint in CONSTRAINT_SPECS (and schema.xml) for the p10→p11 gate, or reuse `C-review-consensus` (which already handles p10→p11) for the blocker count check. Update check_blocker_gate to use the appropriate constraint_id.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:23:37Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:23:37Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-r1n","title":"SLICE-5-L1: Types — Temporal workflow types + search attrs + pyproject.toml","description":"---\nreferences:\n  slice: aura-plugins-lkz\n  impl_plan: aura-plugins-06g\n---\n## Scope\nDefine Temporal types: EpochInput, EpochResult, PhaseAdvanceSignal, ReviewVoteSignal (frozen dataclasses). Define search attribute keys. Update pyproject.toml with temporalio\u003e=1.9.0 and dev deps.\n\n## Files Owned\n- scripts/aura_protocol/workflow.py (type defs + search attrs)\n- pyproject.toml (MODIFY)\n\n## Acceptance Criteria\nGiven workflow.py when imported then all signal/query types importable should never import state_machine internals (only public API)","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:45Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:17:11Z","closed_at":"2026-02-22T02:17:11Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"]}
{"id":"aura-plugins-r8f","title":"SLICE-5-REVIEW-A-1 MINOR: SA_EPOCH_ID not updated in per-transition upsert_search_attributes call","description":"## Finding\n\n### Location\n`scripts/aura_protocol/workflow.py`, `run()` method, lines 301-310:\n\n```python\nworkflow.upsert_search_attributes(\n    [\n        SA_PHASE.value_set(current.value),\n        SA_ROLE.value_set(self._sm.state.current_role),\n        SA_STATUS.value_set(\n            'complete' if current == PhaseId.COMPLETE else 'running'\n        ),\n        SA_DOMAIN.value_set(domain_value),\n    ]\n)\n```\n\n### Description\nThe initial `upsert_search_attributes` call (lines 225-233) correctly sets all 5 attributes including `SA_EPOCH_ID`. However, the per-transition update (lines 301-310) omits `SA_EPOCH_ID`. Since `SA_EPOCH_ID` does not change across transitions, this is functionally correct — the initial value persists.\n\nHowever, the omission creates inconsistency: if Temporal ever resets search attributes (e.g., during a workflow reset or namespace migration), the per-transition upsert would not restore `SA_EPOCH_ID`.\n\n### Risk\nMINOR — SA_EPOCH_ID is set once at initialization and is immutable (the epoch_id doesn't change). Temporal's search attributes are persistent unless explicitly cleared. No functional bug for v1.\n\n### Suggestion\nFor defensive correctness, include `SA_EPOCH_ID.value_set(input.epoch_id)` in the per-transition upsert, or document explicitly that SA_EPOCH_ID is set-once and intentionally omitted from transition updates.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:25:33Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:25:33Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-r8m","title":"SLICE-2-REVIEW-C-1-F1: EpochState.current_role typed str instead of RoleId breaks enum invariant","description":"## Finding\n\nIn state_machine.py, EpochState.current_role is typed as str (line 47):\n\n    current_role: str = 'epoch'\n\nBut the entire design uses strongly-typed enums (RoleId is a str Enum). This breaks the type invariant that the proposal and types.py establish: 'Prefer using strongly-typed enums instead of stringly-typed API, return values, or arguments.'\n\nThe check_role_ownership constraint method in constraints.py must then do a runtime string comparison:\n    known_roles = {r.value for r in RoleId}\n    if state.current_role not in known_roles:\n\n...rather than getting compile-time type safety from RoleId.\n\nIf current_role were typed RoleId, the comparison would be isinstance(state.current_role, RoleId) and the constraint method body would be simpler and safer.\n\n## Impact\n- Type errors from callers passing arbitrary strings are not caught at static analysis time\n- The search attribute upsert in workflow.py passes current_role directly as a string value — any typo would silently produce a bad SA_ROLE value\n- Inconsistent with all other typed fields in the module\n\n## Fix\nChange EpochState.current_role to: current_role: RoleId = RoleId.EPOCH\nUpdate any callers or tests that set current_role to use the enum.\nThis is a one-line change with straightforward downstream cleanup.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:23Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:21:23Z","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-s6i","title":"FOLLOWUP_URD: Requirements for aura_protocol v1 follow-up","description":"---\nreferences:\n  followup_epic: aura-plugins-2tj\n  original_urd: aura-plugins-umi\n---\nFollow-up requirements. References original URD.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:27:37Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:27:37Z","labels":["aura:p2-user:s2_2-urd","aura:urd"]}
{"id":"aura-plugins-sgf","title":"SLICE-3-REVIEW-C-1 BLOCKER","description":"Reviewer C (Elegance) — SLICE-3 BLOCKER severity group.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:38Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:22:57Z","closed_at":"2026-02-22T02:22:57Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-sk6","title":"SLICE-5-REVIEW-B-1 MINOR","description":"Reviewer B (Test Quality) — SLICE-5 (workflow.py) minor-level findings.\n\n## Finding: _advance_to helper duplicated from test_state_machine.py — should be shared conftest.py fixture (MINOR)\n\nSame finding as noted in SLICE-2. The _advance_to helper with the _FORWARD list and gate satisfaction logic is copy-pasted identically in test_workflow.py (lines 74-109) and test_state_machine.py (lines 41-85). A conftest.py fixture or shared utility module would eliminate the drift risk.\n\n## Finding: TestSearchAttributeKeys does not verify SA_EPOCH_ID.value_type is text (distinct from keyword) — the test only checks name and that value_set() works (MINOR)\n\nSA_EPOCH_ID is created with SearchAttributeKey.for_text() (text, full-text indexed) while SA_PHASE, SA_ROLE, SA_STATUS, SA_DOMAIN are created with for_keyword() (exact match). The test verifies names and that value_set() returns something, but does not distinguish between text and keyword key types. A future change from for_text to for_keyword would not be caught. This is minor because the production code is correct and the test comment documents the intent.\n\n## Finding: TestWorkflowStructure uses __temporal_workflow_run attribute check that is an implementation detail of the Temporal Python SDK — could break on SDK version upgrade (MINOR)\n\nThe tests check hasattr(method, '__temporal_workflow_run'), '__temporal_signal_definition', '__temporal_query_definition'. These are internal SDK attributes and not part of the public API. They could change in a minor SDK update. This is accepted in practice for Temporal introspection tests, but worth noting.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:23:13Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:23:13Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-tcn","title":"SLICE-2-REVIEW-A-1 IMPORTANT","description":"Reviewer A (Correctness) — SLICE-2 (state_machine.py) — IMPORTANT findings.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:53Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:21:53Z","labels":["aura:p10-impl:s10-review","aura:severity:important"],"dependencies":[{"issue_id":"aura-plugins-tcn","depends_on_id":"aura-plugins-ipj","type":"blocks","created_at":"2026-02-21T18:22:24Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-umi","title":"URD: Machine-executable aura protocol engine with Temporal orchestration","description":"---\nreferences:\n  request: aura-plugins-bj1\n  elicit: aura-plugins-gbr\n  related_epoch: aura-plugins-220\n  variant_rich_paper: Strüber et al. SPLC'19 (DOI: 10.1145/3336294.3336302)\n  agentfilter_project: ~/codebases/dayvidpham/agentfilter/\n  unified_schema_project: ~/dev/agent-data-leverage/unified-schema/\n  temporal_research: ~/codebases/dayvidpham/nix-openclaw-vm/docs/research/temporal*.Rmd\n  collaboration_protocol: ~/dev/agent-data-leverage/david-data-ingestion-typescript-pipeline/initial-collaboration-protocol.md\n  nlp_proposal: ~/dev/agent-data-leverage/david-data-ingestion-typescript-pipeline/nlp-project-proposal.md\n---\n\n## Requirements\n\n### R1: Machine-Executable 12-Phase Protocol (v1 MVP)\nExtend validate_schema.py to enforce workflow state transitions. Add a state machine (Python, Temporal SDK) that validates phase ordering, review consensus gates, and dependency chain integrity. Temporal provides durability, audit trail, and search attributes for forensic queryability.\n\n### R2: Schema.xml Runtime Context Injection (v2)\nParse schema.xml at agent startup and inject the relevant phase/role/constraint context into the agent's prompt. Single source of truth — eliminates SKILL.md drift. Constraints checked at injection time.\n\n### R3: Full Temporal Workflow Engine (v3)\nImplement the 12-phase protocol as Temporal workflows. Phases become workflows, handoffs become signals, constraints become activity guards. Agents orchestrated by Temporal rather than reading SKILL.md.\n\n### R4: Hybrid Schema Strategy\n- Core: Typed enums (Python newtype pattern) for universal fields (session_id, model_id, role, phase)\n- Deltas: Per-harness extension modules for harness-specific transcript fields\n- Feature guards: Cross-cutting constraints verified by SAT solver (z3 or python-sat)\n- Matches unified-schema's existing BCNF approach but extends it for the aura protocol dimensions\n\n### R5: A2A/MCP Type Compliance\n- Adopt A2A Part discriminated union (TextPart/FilePart/DataPart) for content representation\n- Adopt MCP ToolUseContent/ToolResultContent for tool call representation\n- Adopt A2A TaskState enum as superset of all protocol lifecycle states\n- Extend with: reasoning field (ACP TrajectoryMetadata), source field (harness+model), tool/system roles\n- Use models.dev {provider_id}/{model_id} for stable model identifiers\n\n### R6: Integration Interfaces (End Vision)\nDefine interfaces that bridge:\n- aura-plugins (protocol definition + constraint enforcement)\n- unified-schema (transcript ingestion + analytics — NOT modified by us)\n- agentfilter (security filtering — NOT modified by us)\n- nix-openclaw-vm (Temporal runtime — eventual execution backend)\n\n### R7: Python-Only in aura-plugins\nAll code in aura-plugins must be Python. Temporal Python SDK for workflow engine. No Go in this repo (Go lives in unified-schema and nix-openclaw-vm).\n\n### R8: Beads Coordination (Transitional)\nBeads (bd CLI) remains the inter-agent task coordination mechanism for now. Eventually superseded by our own solution using the APIs we develop. The orchestration layer must integrate with beads, not replace it prematurely.\n\n## Priorities (User-Stated)\n1. v1 MVP: Constraint validator + state machine with Temporal (Python SDK)\n2. Cross-project integration interfaces (define, don't implement outside aura-plugins)\n3. A2A/MCP type compliance for future interop\n4. Hybrid schema for variant-rich harness support\n\n## Design Choices (From Elicitation)\n- Temporal throughout all versions (Python SDK)\n- unified-schema team owns SessionEntry DB schema (we don't modify)\n- Hybrid schema: typed enums (core) + deltas (harness-specific) + feature guards (cross-cutting)\n- Beads is transitional; Temporal audit trail is the long-term solution\n\n## MVP Goals (v1)\n1. Python state machine that models the 12-phase aura protocol transitions\n2. Temporal workflow that wraps the state machine with durable execution\n3. Constraint validators (extending validate_schema.py) that check runtime state\n4. Search attributes on Temporal for forensic queries (phase, role, agent, status)\n5. Integration interface definitions (Python protocols/ABCs) for unified-schema and agentfilter\n\n## End-Vision Goals\nCompletely auditable agent workflow engine for open-source development:\n- Agents orchestrated by Temporal workflows with durable state\n- schema.xml as single source of truth — runtime context injected, not read from SKILL.md\n- Cross-project integration: protocol enforcement (aura-plugins) + ingestion (unified-schema) + security (agentfilter) + execution (Temporal)\n- Open contribution: the orchestration APIs become the \"Application Document Interface\" for agent-native development\n- Audit trail: every phase transition, constraint check, handoff, and review decision is recorded in Temporal event history with search attributes","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T00:39:07Z","created_by":"David Huu Pham","updated_at":"2026-02-22T00:39:07Z","labels":["aura:p2-user:s2_2-urd","aura:urd"],"comments":[{"id":8,"issue_id":"aura-plugins-umi","author":"David Huu Pham","text":"Ratified: PROPOSAL-1 (aura-plugins-gmv) accepted. Scope: v1 MVP — 5 Python modules (types, state_machine, constraints, workflow, interfaces) with 6 test files. Pure Python state machine + Temporal workflow wrapper.","created_at":"2026-02-22T01:17:09Z"}]}
{"id":"aura-plugins-utj","title":"SLICE-4-REVIEW-C-1 MINOR","description":"Reviewer C (Elegance) — SLICE-4 MINOR severity group.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:46Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:20:46Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"],"dependencies":[{"issue_id":"aura-plugins-utj","depends_on_id":"aura-plugins-eqy","type":"blocks","created_at":"2026-02-21T18:22:36Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-v1b","title":"SLICE-2-REVIEW-B-1 MINOR","description":"Reviewer B (Test Quality) — SLICE-2 (state_machine.py) minor-level findings.\n\n## Finding: TestDependencyInjection uses __import__ inline — prefer a direct import at top of test (MINOR)\n\nIn test_state_machine.py TestDependencyInjection.test_custom_specs_used, the Domain type is imported via:\n    domain=__import__('aura_protocol.types', fromlist=['Domain']).Domain.USER\n\nThis is unconventional and obscures the dependency. A clean import at the top of the test or inside the test method (from aura_protocol.types import Domain) is clearer and follows the codebase's import style.\n\n## Finding: _advance_to helper is duplicated between test_state_machine.py and test_workflow.py (MINOR)\n\nThe _advance_to helper function with its _FORWARD list and gate-satisfaction logic is copy-pasted identically in both test files. A shared conftest.py fixture would eliminate this duplication and ensure both test files stay synchronized when the phase sequence changes. This is a test maintainability concern (not a correctness issue since both copies are currently identical).","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:29Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:21:29Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"]}
{"id":"aura-plugins-w28","title":"SLICE-3-L2: Tests — test_constraints.py (AC5, all C-* constraints)","description":"---\nreferences:\n  slice: aura-plugins-mrm\n  impl_plan: aura-plugins-06g\n---\n## Scope\nWrite test_constraints.py testing AC5 and all C-* constraint checks. Tests import from constraints.py and WILL FAIL until L3.\n\n## Files Owned\n- tests/test_constraints.py\n\n## Acceptance Criteria\nGiven test_constraints.py when run before L3 then tests fail should never pass without real constraint logic","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T01:32:41Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:05:52Z","closed_at":"2026-02-22T02:05:52Z","close_reason":"Closed","labels":["aura:p9-impl:s9-slice"],"dependencies":[{"issue_id":"aura-plugins-w28","depends_on_id":"aura-plugins-eel","type":"blocks","created_at":"2026-02-21T17:32:41Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-wqw","title":"ELICIT: Release automation requirements","description":"---\nreferences:\n  request: aura-plugins-j2k\n---\n\n## URE Survey Results (Verbatim)\n\n### Q1: What semver bump types should the tool support?\n**Answer:** major, minor, patch (Recommended)\n\u003e Standard 3-level semver bumps (e.g., 0.2.2 → 0.3.0, 0.2.3, 1.0.0)\n\n### Q2: Should the tool also fix the current version drift (marketplace.json at 0.2.1)?\n**Answer:** Yes, fix as part of this feature (Recommended)\n\u003e The release tool's first run will sync all 3 files to the same version\n\n### Q3: What post-bump actions should the tool perform?\n**Answer:** Commit + tag (Recommended)\n\u003e Auto-commit the version files and create an annotated git tag (vX.Y.Z)\n\n### Q4: Should the tool include CHANGELOG generation?\n**Answer:** Yes, auto-generate\n\u003e Generate CHANGELOG.md from git log between tags (Keep a Changelog format)","status":"open","priority":2,"issue_type":"task","assignee":"architect","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:10:23Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:10:23Z","labels":["aura:p2-user:s2_1-elicit"],"dependencies":[{"issue_id":"aura-plugins-wqw","depends_on_id":"aura-plugins-99q","type":"blocks","created_at":"2026-02-21T12:10:49Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-wux","title":"PROPOSAL-1: bin/aura-release — version bump, changelog, and tag tool","description":"---\nreferences:\n  request: aura-plugins-j2k\n  elicit: aura-plugins-wqw\n  urd: aura-plugins-99q\n---\n\n# PROPOSAL-1: bin/aura-release\n\n## Summary\n\nA single Python 3.10+ script (stdlib only) at bin/aura-release that:\n1. Bumps version across 3 manifest files\n2. Auto-generates CHANGELOG.md from git log\n3. Creates a commit and annotated git tag\n\n## Architecture\n\n### Single-file design\nFollowing the bin/aura-swarm and bin/aura-parallel convention:\n- Shebang: #!/usr/bin/env python3\n- argparse CLI, no external dependencies\n- ~300-400 lines estimated\n\n### Version file map\n\n| File | Field(s) | Parse method |\n|------|----------|-------------|\n| pyproject.toml | project.version (line ~3) | Regex on `version = \"X.Y.Z\"` |\n| .claude-plugin/plugin.json | .version | json.load/dump |\n| .claude-plugin/marketplace.json | .metadata.version + .plugins[0].version | json.load/dump |\n\nNote: plugins[1] (agentfilter) is never touched.\n\n### CLI interface\n\n```\nbin/aura-release \u003cmajor|minor|patch\u003e [options]\nbin/aura-release --check\n```\n\nOptions:\n- --dry-run: Show what would happen, change nothing\n- --sync: Align all files to pyproject.toml version before bumping\n- --no-changelog: Skip CHANGELOG generation\n- --no-commit: Skip git commit\n- --no-tag: Skip git tag creation\n\n### Workflow (happy path)\n\n1. Pre-flight checks:\n   - Not detached HEAD\n   - Working tree clean (allow .beads/ changes)\n   - All 3 version files have same version (or --sync used)\n2. Parse current version from pyproject.toml\n3. Compute new version (semver bump)\n4. Update 3 files (4 version fields total)\n5. Generate CHANGELOG.md entry:\n   - Find previous tag (or use root commit if none)\n   - Collect commits since last tag\n   - Group by conventional commit prefix (feat, fix, chore, refactor, etc.)\n   - Prepend new section to CHANGELOG.md (create if missing)\n   - Format: Keep a Changelog (https://keepachangelog.com)\n6. Stage files: pyproject.toml, plugin.json, marketplace.json, CHANGELOG.md\n7. Commit: \"chore: release vX.Y.Z\"\n8. Tag: annotated vX.Y.Z with message \"Release vX.Y.Z\"\n9. Print summary and remind user to push\n\n### Error recovery\n- If any step fails after file modification, restore files via git checkout\n- JSON files written with indent=2 to preserve formatting\n- TOML updated via regex to avoid adding a TOML library dependency\n\n### --check mode\nJust validates version consistency across all 3 files and exits with code 0 (consistent) or 1 (drift detected), printing the versions found.\n\n## Nix integration\n- flake.nix already wraps bin/* scripts → aura-release will auto-package\n- No version field in flake.nix → no changes needed there\n\n## Files to create/modify\n- bin/aura-release (NEW)\n- CHANGELOG.md (created on first release)\n\n## What this does NOT do\n- Push to remote (user does this manually)\n- Create GitHub releases (can be done later via gh release create)\n- Modify flake.nix or nix/hm-module.nix","status":"open","priority":2,"issue_type":"feature","assignee":"architect","owner":"dayvidpham@gmail.com","created_at":"2026-02-21T20:11:23Z","created_by":"David Huu Pham","updated_at":"2026-02-21T20:11:23Z","labels":["aura:p3-plan:s3-propose"],"dependencies":[{"issue_id":"aura-plugins-wux","depends_on_id":"aura-plugins-1ey","type":"blocks","created_at":"2026-02-21T12:13:28Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-x36","title":"SLICE-5-REVIEW-C-1 MINOR","description":"Reviewer C (Elegance) — SLICE-5 MINOR severity group.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:47Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:20:47Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"],"dependencies":[{"issue_id":"aura-plugins-x36","depends_on_id":"aura-plugins-3m4","type":"blocks","created_at":"2026-02-21T18:22:52Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-xui","title":"SLICE-5-REVIEW-A-1 MINOR","description":"Reviewer A (Correctness) — SLICE-5 (workflow.py) — MINOR findings.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:24:51Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:24:51Z","labels":["aura:p10-impl:s10-review","aura:severity:minor"],"dependencies":[{"issue_id":"aura-plugins-xui","depends_on_id":"aura-plugins-r8f","type":"blocks","created_at":"2026-02-21T18:25:37Z","created_by":"David Huu Pham","metadata":"{}"}]}
{"id":"aura-plugins-ye3","title":"SLICE-1-REVIEW-B-1 BLOCKER","description":"Reviewer B (Test Quality) — SLICE-1 (types.py / __init__.py) blocker-level findings.\n\n## Finding Summary\n\nNO BLOCKER findings identified for SLICE-1.\n\nTests import correctly from production modules (aura_protocol package).\nSUT (types.py) is NOT mocked — tests exercise real enum and dataclass instances.\nObservable outcomes tested: enum membership, JSON serialization, FrozenInstanceError, dict contents.\nSchema integration test (test_schema_types_sync.py) parses the real schema.xml.\n\nThis group is empty and will be closed immediately.","status":"closed","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:20:28Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:20:58Z","closed_at":"2026-02-22T02:20:58Z","close_reason":"Closed","labels":["aura:p10-impl:s10-review","aura:severity:blocker"]}
{"id":"aura-plugins-yno","title":"SLICE-3-REVIEW-B-1 IMPORTANT","description":"Reviewer B (Test Quality) — SLICE-3 (constraints.py) important-level findings.\n\n## Finding: check_all only aggregates 5 of the 22 C-* constraint checks — the 17 remaining utility checks are not reachable via check_all(state) alone — test coverage gap for the integrated aggregation path (IMPORTANT)\n\nconstraints.py check_all() aggregates:\n  check_review_consensus, check_severity_tree, check_blocker_gate, check_audit_trail, check_role_ownership\n\nThe other 17 constraint checkers (check_review_binary, check_dep_direction, check_blocker_dual_parent, check_proposal_naming, check_review_naming, check_slice_has_leaf_tasks, check_ure_verbatim, check_followup_timing, check_agent_commit, check_frontmatter_refs, check_supervisor_no_impl, check_followup_lifecycle, check_followup_leaf_adoption, check_worker_gates, check_supervisor_explore_team, check_vertical_slices, check_handoff_required) are NOT included in check_all.\n\nThis means check_all is only a partial aggregate. The test TestCrossConstraintIntegration validates that check_all aggregates correctly across what IS in it, but no test asserts that check_all(state) returns violations from the full set of 22 constraints.\n\nThis architectural decision may be intentional (some constraints require external parameters beyond EpochState), but the test suite has no test that:\n1. Documents which constraints ARE in check_all vs not.\n2. Verifies that check_all output + the individually callable checkers together cover all 22 C-* specs.\n\nThis gap means a caller who calls only check_all(state) would get a false sense of completeness. A follow-up epic should add either documentation or a cross-module integration test that validates the coverage contract.\n\nSeverity: IMPORTANT because it affects the semantic contract of the most important public method.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:21:55Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:21:55Z","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
{"id":"aura-plugins-z3n","title":"SLICE-5-REVIEW-C-1: workflow.py — Temporal workflow wrapper","description":"VOTE: ACCEPT\n\n## Review Summary (Reviewer C — Elegance and Complexity Proportionality)\n\nSLICE-5 (workflow.py) correctly wraps the state machine with Temporal without over-engineering the integration layer.\n\n### Strengths\n- Signal-driven state mutations (advance_phase, submit_vote) vs query-driven reads (current_state, available_transitions) is exactly the correct split for Temporal determinism. Signals for mutations, queries for reads — the design is idiomatic Temporal.\n- Pending-queue pattern (_pending_advance, _pending_votes) for signal delivery is clean: signals enqueue, run() loop drains. This correctly handles signal ordering and prevents activity scheduling inside signal handlers.\n- Activities at the right boundaries: check_constraints and record_transition are activities because they represent I/O boundaries (external constraint evaluation, external persistence). State machine advance is workflow code because it is deterministic. The boundary is drawn correctly.\n- One workflow per epoch (not per phase) is the correct v1 granularity. The comment correctly defers per-phase parallelism to v3.\n- Search attributes upserting on every transition is correct and complete: SA_EPOCH_ID, SA_PHASE, SA_ROLE, SA_STATUS, SA_DOMAIN all updated atomically after each successful advance.\n- record_transition as a stub activity that logs and returns — the extension point is defined now for v2 without adding fake behavior.\n- workflow.now() used for deterministic timestamps instead of datetime.now(). The comment and docstring both flag this invariant.\n\n### Important Finding\n- aura-plugins-i2g: Bare except Exception in run() loop silently discards TransitionError. The caller (whoever sent the advance_phase signal) gets no feedback that the transition was rejected. Failed transition attempts are not recorded in the audit trail.\n\n### Minor Finding\n- aura-plugins-3m4: Post-hoc mutation of TransitionRecord in transition_history list (replacing the last element with a deterministic-timestamp copy). Technically legal but subtle and unexpected, given TransitionRecord is documented as immutable. A cleaner fix is to pass the timestamp into advance().\n\n### Verdict\nNo BLOCKER findings. One IMPORTANT finding (silent failure on advance rejection), one MINOR finding (post-hoc mutation pattern). SLICE-5 ACCEPT — the IMPORTANT finding affects debuggability and auditability but does not break correctness for the v1 happy path.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:24:35Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:24:35Z","labels":["aura:p10-impl:s10-review"]}
{"id":"aura-plugins-zpu","title":"SLICE-4-REVIEW-A-1 IMPORTANT: ConstraintValidatorInterface uses TYPE_CHECKING import for EpochState causing isinstance() Protocol check to be structurally incomplete","description":"## Finding\n\n### Location\n`scripts/aura_protocol/interfaces.py`, lines 33-38:\n\n```python\nif TYPE_CHECKING:\n    from aura_protocol.constraints import ConstraintViolation  # noqa: F401\n    from aura_protocol.state_machine import EpochState  # noqa: F401\n```\n\n### Description\nBoth `ConstraintViolation` and `EpochState` are imported only under `TYPE_CHECKING`. This means at RUNTIME these names are NOT available in the `interfaces` module scope.\n\nThe `ConstraintValidatorInterface.validate` method signature references `EpochState` and `list[ConstraintViolation]`:\n\n```python\ndef validate(self, state: EpochState) -\u003e list[ConstraintViolation]: ...\n`\\:\n\nAt RUNTIME, Python's `@runtime_checkable` Protocol uses structural subtyping based on method NAME presence only (not signature matching for isinstance). So `isinstance(obj, ConstraintValidatorInterface)` checks only that `obj` has a `validate` attribute — it does NOT verify the parameter types or return type.\n\nThis means:\n1. AC9 tests pass because isinstance() only checks method name existence\n2. The TYPE_CHECKING-only imports are CORRECT for avoiding circular imports at runtime\n3. However, this creates a documentation/clarity gap: the interface signature is checked only statically (mypy), not at runtime\n\n### Risk\nIMPORTANT (not BLOCKER) because: (1) this is the correct Python typing.Protocol pattern for avoiding circular imports — the code comment explicitly explains it; (2) AC9 is correctly met: isinstance() returns True for correct implementors; (3) type checking via mypy/pyright provides the signature enforcement. The implementation is correct per Python Protocol semantics.\n\nThe concern is that a future implementor might not realize the signature mismatch will not be caught at runtime, only at static analysis time. This should be clearly documented in the module docstring.\n\n### Suggestion\nAdd a comment in the module docstring noting: 'Note: EpochState and ConstraintViolation are TYPE_CHECKING-only imports to avoid circular imports. Runtime isinstance() checks only verify method name presence (as per Python typing.Protocol semantics); full signature enforcement requires static type checking.' This ensures future implementors understand the runtime vs. static checking distinction.","status":"open","priority":2,"issue_type":"task","owner":"dayvidpham@gmail.com","created_at":"2026-02-22T02:24:17Z","created_by":"David Huu Pham","updated_at":"2026-02-22T02:24:17Z","labels":["aura:p10-impl:s10-review","aura:severity:important"]}
